/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-b0c5770c","./Matrix2-5bde29de","./ComponentDatatype-164c57e1","./defaultValue-ac2201bb","./RuntimeError-d45af186","./GeometryAttribute-6f7c565e","./GeometryAttributes-d060f8b5","./GeometryOffsetAttribute-a17b96d9","./IndexDatatype-4e1ec1a1","./VertexFormat-4a6cdfad"],(function(t,e,a,n,i,r,o,s,m,u,l){"use strict";const c=new a.Cartesian3,f=new a.Cartesian3,d=new a.Cartesian3,p=new a.Cartesian3,C=new a.Cartesian3,y=new a.Cartesian3(1,1,1),h=Math.cos,_=Math.sin;function x(t){t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT);const e=i.defaultValue(t.radii,y),o=i.defaultValue(t.innerRadii,e),s=i.defaultValue(t.minimumClock,0),m=i.defaultValue(t.maximumClock,n.CesiumMath.TWO_PI),u=i.defaultValue(t.minimumCone,0),c=i.defaultValue(t.maximumCone,n.CesiumMath.PI),f=Math.round(i.defaultValue(t.stackPartitions,64)),d=Math.round(i.defaultValue(t.slicePartitions,64)),p=i.defaultValue(t.vertexFormat,l.VertexFormat.DEFAULT);if(d<3)throw new r.DeveloperError("options.slicePartitions cannot be less than three.");if(f<3)throw new r.DeveloperError("options.stackPartitions cannot be less than three.");this._radii=a.Cartesian3.clone(e),this._innerRadii=a.Cartesian3.clone(o),this._minimumClock=s,this._maximumClock=m,this._minimumCone=u,this._maximumCone=c,this._stackPartitions=f,this._slicePartitions=d,this._vertexFormat=l.VertexFormat.clone(p),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}x.packedLength=2*a.Cartesian3.packedLength+l.VertexFormat.packedLength+7,x.pack=function(t,e,n){if(!i.defined(t))throw new r.DeveloperError("value is required");if(!i.defined(e))throw new r.DeveloperError("array is required");return n=i.defaultValue(n,0),a.Cartesian3.pack(t._radii,e,n),n+=a.Cartesian3.packedLength,a.Cartesian3.pack(t._innerRadii,e,n),n+=a.Cartesian3.packedLength,l.VertexFormat.pack(t._vertexFormat,e,n),n+=l.VertexFormat.packedLength,e[n++]=t._minimumClock,e[n++]=t._maximumClock,e[n++]=t._minimumCone,e[n++]=t._maximumCone,e[n++]=t._stackPartitions,e[n++]=t._slicePartitions,e[n]=i.defaultValue(t._offsetAttribute,-1),e};const A=new a.Cartesian3,b=new a.Cartesian3,w=new l.VertexFormat,k={radii:A,innerRadii:b,vertexFormat:w,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let v;x.unpack=function(t,e,n){if(!i.defined(t))throw new r.DeveloperError("array is required");e=i.defaultValue(e,0);const o=a.Cartesian3.unpack(t,e,A);e+=a.Cartesian3.packedLength;const s=a.Cartesian3.unpack(t,e,b);e+=a.Cartesian3.packedLength;const m=l.VertexFormat.unpack(t,e,w);e+=l.VertexFormat.packedLength;const u=t[e++],c=t[e++],f=t[e++],d=t[e++],p=t[e++],C=t[e++],y=t[e];return i.defined(n)?(n._radii=a.Cartesian3.clone(o,n._radii),n._innerRadii=a.Cartesian3.clone(s,n._innerRadii),n._vertexFormat=l.VertexFormat.clone(m,n._vertexFormat),n._minimumClock=u,n._maximumClock=c,n._minimumCone=f,n._maximumCone=d,n._stackPartitions=p,n._slicePartitions=C,n._offsetAttribute=-1===y?void 0:y,n):(k.minimumClock=u,k.maximumClock=c,k.minimumCone=f,k.maximumCone=d,k.stackPartitions=p,k.slicePartitions=C,k.offsetAttribute=-1===y?void 0:y,new x(k))},x.createGeometry=function(t){const r=t._radii;if(r.x<=0||r.y<=0||r.z<=0)return;const l=t._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;const y=t._minimumClock,x=t._maximumClock,A=t._minimumCone,b=t._maximumCone,w=t._vertexFormat;let k,v,P=t._slicePartitions+1,g=t._stackPartitions+1;P=Math.round(P*Math.abs(x-y)/n.CesiumMath.TWO_PI),g=Math.round(g*Math.abs(b-A)/n.CesiumMath.PI),P<2&&(P=2),g<2&&(g=2);let F=0;const V=[A],D=[y];for(k=0;k<g;k++)V.push(A+k*(b-A)/(g-1));for(V.push(b),v=0;v<P;v++)D.push(y+v*(x-y)/(P-1));D.push(x);const E=V.length,M=D.length;let T=0,G=1;const L=l.x!==r.x||l.y!==r.y||l.z!==r.z;let O=!1,I=!1,z=!1;L&&(G=2,A>0&&(O=!0,T+=P-1),b<Math.PI&&(I=!0,T+=P-1),(x-y)%n.CesiumMath.TWO_PI?(z=!0,T+=2*(g-1)+1):T+=1);const N=M*E*G,R=new Float64Array(3*N),U=new Array(N).fill(!1),S=new Array(N).fill(!1),B=P*g*G,W=6*(B+T+1-(P+g)*G),q=u.IndexDatatype.createTypedArray(B,W),Y=w.normal?new Float32Array(3*N):void 0,J=w.tangent?new Float32Array(3*N):void 0,X=w.bitangent?new Float32Array(3*N):void 0,Z=w.st?new Float32Array(2*N):void 0,j=new Array(E),H=new Array(E);for(k=0;k<E;k++)j[k]=_(V[k]),H[k]=h(V[k]);const K=new Array(M),Q=new Array(M);for(v=0;v<M;v++)Q[v]=h(D[v]),K[v]=_(D[v]);for(k=0;k<E;k++)for(v=0;v<M;v++)R[F++]=r.x*j[k]*Q[v],R[F++]=r.y*j[k]*K[v],R[F++]=r.z*H[k];let $,tt,et,at,nt=N/2;if(L)for(k=0;k<E;k++)for(v=0;v<M;v++)R[F++]=l.x*j[k]*Q[v],R[F++]=l.y*j[k]*K[v],R[F++]=l.z*H[k],U[nt]=!0,k>0&&k!==E-1&&0!==v&&v!==M-1&&(S[nt]=!0),nt++;for(F=0,k=1;k<E-2;k++)for($=k*M,tt=(k+1)*M,v=1;v<M-2;v++)q[F++]=tt+v,q[F++]=tt+v+1,q[F++]=$+v+1,q[F++]=tt+v,q[F++]=$+v+1,q[F++]=$+v;if(L){const t=E*M;for(k=1;k<E-2;k++)for($=t+k*M,tt=t+(k+1)*M,v=1;v<M-2;v++)q[F++]=tt+v,q[F++]=$+v,q[F++]=$+v+1,q[F++]=tt+v,q[F++]=$+v+1,q[F++]=tt+v+1}if(L){if(O)for(at=E*M,k=1;k<M-2;k++)q[F++]=k,q[F++]=k+1,q[F++]=at+k+1,q[F++]=k,q[F++]=at+k+1,q[F++]=at+k;if(I)for(et=E*M-M,at=E*M*G-M,k=1;k<M-2;k++)q[F++]=et+k+1,q[F++]=et+k,q[F++]=at+k,q[F++]=et+k+1,q[F++]=at+k,q[F++]=at+k+1}if(z){for(k=1;k<E-2;k++)at=M*E+M*k,et=M*k,q[F++]=at,q[F++]=et+M,q[F++]=et,q[F++]=at,q[F++]=at+M,q[F++]=et+M;for(k=1;k<E-2;k++)at=M*E+M*(k+1)-1,et=M*(k+1)-1,q[F++]=et+M,q[F++]=at,q[F++]=et,q[F++]=et+M,q[F++]=at+M,q[F++]=at}const it=new s.GeometryAttributes;w.position&&(it.position=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:R}));let rt=0,ot=0,st=0,mt=0;const ut=N/2;let lt;const ct=a.Ellipsoid.fromCartesian3(r),ft=a.Ellipsoid.fromCartesian3(l);if(w.st||w.normal||w.tangent||w.bitangent){for(k=0;k<N;k++){lt=U[k]?ft:ct;const t=a.Cartesian3.fromArray(R,3*k,c),e=lt.geodeticSurfaceNormal(t,f);if(S[k]&&a.Cartesian3.negate(e,e),w.st){const t=a.Cartesian2.negate(e,C);Z[rt++]=Math.atan2(t.y,t.x)/n.CesiumMath.TWO_PI+.5,Z[rt++]=Math.asin(e.z)/Math.PI+.5}if(w.normal&&(Y[ot++]=e.x,Y[ot++]=e.y,Y[ot++]=e.z),w.tangent||w.bitangent){const t=d;let n,i=0;if(U[k]&&(i=ut),n=!O&&k>=i&&k<i+2*M?a.Cartesian3.UNIT_X:a.Cartesian3.UNIT_Z,a.Cartesian3.cross(n,e,t),a.Cartesian3.normalize(t,t),w.tangent&&(J[st++]=t.x,J[st++]=t.y,J[st++]=t.z),w.bitangent){const n=a.Cartesian3.cross(e,t,p);a.Cartesian3.normalize(n,n),X[mt++]=n.x,X[mt++]=n.y,X[mt++]=n.z}}}w.st&&(it.st=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Z})),w.normal&&(it.normal=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y})),w.tangent&&(it.tangent=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:J})),w.bitangent&&(it.bitangent=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:X}))}if(i.defined(t._offsetAttribute)){const e=R.length,a=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(a);it.applyOffset=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new o.Geometry({attributes:it,indices:q,primitiveType:o.PrimitiveType.TRIANGLES,boundingSphere:e.BoundingSphere.fromEllipsoid(ct),offsetAttribute:t._offsetAttribute})},x.getUnitEllipsoid=function(){return i.defined(v)||(v=x.createGeometry(new x({radii:new a.Cartesian3(1,1,1),vertexFormat:l.VertexFormat.POSITION_ONLY}))),v},t.EllipsoidGeometry=x}));
//# sourceMappingURL=EllipsoidGeometry-b771d2a1.js.map
