/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-3f580a0c","./Matrix2-5bde29de","./ComponentDatatype-164c57e1","./defaultValue-ac2201bb","./RuntimeError-d45af186","./GeometryAttribute-f83e6129","./GeometryAttributes-d060f8b5","./GeometryOffsetAttribute-a17b96d9","./IndexDatatype-4e1ec1a1"],(function(e,t,i,r,o,n,a,s,u,m){"use strict";const f=new i.Cartesian3(1,1,1),l=Math.cos,d=Math.sin;function c(e){e=o.defaultValue(e,o.defaultValue.EMPTY_OBJECT);const t=o.defaultValue(e.radii,f),a=o.defaultValue(e.innerRadii,t),s=o.defaultValue(e.minimumClock,0),m=o.defaultValue(e.maximumClock,r.CesiumMath.TWO_PI),l=o.defaultValue(e.minimumCone,0),d=o.defaultValue(e.maximumCone,r.CesiumMath.PI),c=Math.round(o.defaultValue(e.stackPartitions,10)),p=Math.round(o.defaultValue(e.slicePartitions,8)),C=Math.round(o.defaultValue(e.subdivisions,128));if(c<1)throw new n.DeveloperError("options.stackPartitions cannot be less than 1");if(p<0)throw new n.DeveloperError("options.slicePartitions cannot be less than 0");if(C<0)throw new n.DeveloperError("options.subdivisions must be greater than or equal to zero.");if(o.defined(e.offsetAttribute)&&e.offsetAttribute===u.GeometryOffsetAttribute.TOP)throw new n.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=i.Cartesian3.clone(t),this._innerRadii=i.Cartesian3.clone(a),this._minimumClock=s,this._maximumClock=m,this._minimumCone=l,this._maximumCone=d,this._stackPartitions=c,this._slicePartitions=p,this._subdivisions=C,this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}c.packedLength=2*i.Cartesian3.packedLength+8,c.pack=function(e,t,r){if(!o.defined(e))throw new n.DeveloperError("value is required");if(!o.defined(t))throw new n.DeveloperError("array is required");return r=o.defaultValue(r,0),i.Cartesian3.pack(e._radii,t,r),r+=i.Cartesian3.packedLength,i.Cartesian3.pack(e._innerRadii,t,r),r+=i.Cartesian3.packedLength,t[r++]=e._minimumClock,t[r++]=e._maximumClock,t[r++]=e._minimumCone,t[r++]=e._maximumCone,t[r++]=e._stackPartitions,t[r++]=e._slicePartitions,t[r++]=e._subdivisions,t[r]=o.defaultValue(e._offsetAttribute,-1),t};const p=new i.Cartesian3,C=new i.Cartesian3,h={radii:p,innerRadii:C,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};c.unpack=function(e,t,r){if(!o.defined(e))throw new n.DeveloperError("array is required");t=o.defaultValue(t,0);const a=i.Cartesian3.unpack(e,t,p);t+=i.Cartesian3.packedLength;const s=i.Cartesian3.unpack(e,t,C);t+=i.Cartesian3.packedLength;const u=e[t++],m=e[t++],f=e[t++],l=e[t++],d=e[t++],_=e[t++],b=e[t++],y=e[t];return o.defined(r)?(r._radii=i.Cartesian3.clone(a,r._radii),r._innerRadii=i.Cartesian3.clone(s,r._innerRadii),r._minimumClock=u,r._maximumClock=m,r._minimumCone=f,r._maximumCone=l,r._stackPartitions=d,r._slicePartitions=_,r._subdivisions=b,r._offsetAttribute=-1===y?void 0:y,r):(h.minimumClock=u,h.maximumClock=m,h.minimumCone=f,h.maximumCone=l,h.stackPartitions=d,h.slicePartitions=_,h.subdivisions=b,h.offsetAttribute=-1===y?void 0:y,new c(h))},c.createGeometry=function(e){const n=e._radii;if(n.x<=0||n.y<=0||n.z<=0)return;const f=e._innerRadii;if(f.x<=0||f.y<=0||f.z<=0)return;const c=e._minimumClock,p=e._maximumClock,C=e._minimumCone,h=e._maximumCone,_=e._subdivisions,b=i.Ellipsoid.fromCartesian3(n);let y=e._slicePartitions+1,k=e._stackPartitions+1;y=Math.round(y*Math.abs(p-c)/r.CesiumMath.TWO_PI),k=Math.round(k*Math.abs(h-C)/r.CesiumMath.PI),y<2&&(y=2),k<2&&(k=2);let A=0,v=1;const w=f.x!==n.x||f.y!==n.y||f.z!==n.z;let P=!1,x=!1;w&&(v=2,C>0&&(P=!0,A+=y),h<Math.PI&&(x=!0,A+=y));const E=_*v*(k+y),D=new Float64Array(3*E),M=2*(E+A-(y+k)*v),g=m.IndexDatatype.createTypedArray(E,M);let V,G,O,T,z=0;const I=new Array(k),L=new Array(k);for(V=0;V<k;V++)T=C+V*(h-C)/(k-1),I[V]=d(T),L[V]=l(T);const R=new Array(_),N=new Array(_);for(V=0;V<_;V++)O=c+V*(p-c)/(_-1),R[V]=d(O),N[V]=l(O);for(V=0;V<k;V++)for(G=0;G<_;G++)D[z++]=n.x*I[V]*N[G],D[z++]=n.y*I[V]*R[G],D[z++]=n.z*L[V];if(w)for(V=0;V<k;V++)for(G=0;G<_;G++)D[z++]=f.x*I[V]*N[G],D[z++]=f.y*I[V]*R[G],D[z++]=f.z*L[V];for(I.length=_,L.length=_,V=0;V<_;V++)T=C+V*(h-C)/(_-1),I[V]=d(T),L[V]=l(T);for(R.length=y,N.length=y,V=0;V<y;V++)O=c+V*(p-c)/(y-1),R[V]=d(O),N[V]=l(O);for(V=0;V<_;V++)for(G=0;G<y;G++)D[z++]=n.x*I[V]*N[G],D[z++]=n.y*I[V]*R[G],D[z++]=n.z*L[V];if(w)for(V=0;V<_;V++)for(G=0;G<y;G++)D[z++]=f.x*I[V]*N[G],D[z++]=f.y*I[V]*R[G],D[z++]=f.z*L[V];for(z=0,V=0;V<k*v;V++){const e=V*_;for(G=0;G<_-1;G++)g[z++]=e+G,g[z++]=e+G+1}let q=k*_*v;for(V=0;V<y;V++)for(G=0;G<_-1;G++)g[z++]=q+V+G*y,g[z++]=q+V+(G+1)*y;if(w)for(q=k*_*v+y*_,V=0;V<y;V++)for(G=0;G<_-1;G++)g[z++]=q+V+G*y,g[z++]=q+V+(G+1)*y;if(w){let e=k*_*v,t=e+_*y;if(P)for(V=0;V<y;V++)g[z++]=e+V,g[z++]=t+V;if(x)for(e+=_*y-y,t+=_*y-y,V=0;V<y;V++)g[z++]=e+V,g[z++]=t+V}const B=new s.GeometryAttributes({position:new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D})});if(o.defined(e._offsetAttribute)){const t=D.length,i=e._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,o=new Uint8Array(t/3).fill(i);B.applyOffset=new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}return new a.Geometry({attributes:B,indices:g,primitiveType:a.PrimitiveType.LINES,boundingSphere:t.BoundingSphere.fromEllipsoid(b),offsetAttribute:e._offsetAttribute})},e.EllipsoidOutlineGeometry=c}));
//# sourceMappingURL=EllipsoidOutlineGeometry-491d1799.js.map
