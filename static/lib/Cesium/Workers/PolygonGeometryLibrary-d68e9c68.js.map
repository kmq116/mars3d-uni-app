{"version":3,"file":"PolygonGeometryLibrary-d68e9c68.js","sources":["../../../../Source/Core/Queue.js","../../../../Source/Core/PolygonGeometryLibrary.js"],"sourcesContent":["/**\r\n * A queue that can enqueue items at the end, and dequeue items from the front.\r\n *\r\n * @alias Queue\r\n * @constructor\r\n */\r\nfunction Queue() {\r\n  this._array = [];\r\n  this._offset = 0;\r\n  this._length = 0;\r\n}\r\n\r\nObject.defineProperties(Queue.prototype, {\r\n  /**\r\n   * The length of the queue.\r\n   *\r\n   * @memberof Queue.prototype\r\n   *\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  length: {\r\n    get: function () {\r\n      return this._length;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Enqueues the specified item.\r\n *\r\n * @param {*} item The item to enqueue.\r\n */\r\nQueue.prototype.enqueue = function (item) {\r\n  this._array.push(item);\r\n  this._length++;\r\n};\r\n\r\n/**\r\n * Dequeues an item.  Returns undefined if the queue is empty.\r\n *\r\n * @returns {*} The the dequeued item.\r\n */\r\nQueue.prototype.dequeue = function () {\r\n  if (this._length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  const array = this._array;\r\n  let offset = this._offset;\r\n  const item = array[offset];\r\n  array[offset] = undefined;\r\n\r\n  offset++;\r\n  if (offset > 10 && offset * 2 > array.length) {\r\n    //compact array\r\n    this._array = array.slice(offset);\r\n    offset = 0;\r\n  }\r\n\r\n  this._offset = offset;\r\n  this._length--;\r\n\r\n  return item;\r\n};\r\n\r\n/**\r\n * Returns the item at the front of the queue.  Returns undefined if the queue is empty.\r\n *\r\n * @returns {*} The item at the front of the queue.\r\n */\r\nQueue.prototype.peek = function () {\r\n  if (this._length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return this._array[this._offset];\r\n};\r\n\r\n/**\r\n * Check whether this queue contains the specified item.\r\n *\r\n * @param {*} item The item to search for.\r\n */\r\nQueue.prototype.contains = function (item) {\r\n  return this._array.indexOf(item) !== -1;\r\n};\r\n\r\n/**\r\n * Remove all items from the queue.\r\n */\r\nQueue.prototype.clear = function () {\r\n  this._array.length = this._offset = this._length = 0;\r\n};\r\n\r\n/**\r\n * Sort the items in the queue in-place.\r\n *\r\n * @param {Queue.Comparator} compareFunction A function that defines the sort order.\r\n */\r\nQueue.prototype.sort = function (compareFunction) {\r\n  if (this._offset > 0) {\r\n    //compact array\r\n    this._array = this._array.slice(this._offset);\r\n    this._offset = 0;\r\n  }\r\n\r\n  this._array.sort(compareFunction);\r\n};\r\n\r\n/**\r\n * A function used to compare two items while sorting a queue.\r\n * @callback Queue.Comparator\r\n *\r\n * @param {*} a An item in the array.\r\n * @param {*} b An item in the array.\r\n * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\r\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\r\n *          0 if <code>a</code> is equal to <code>b</code>.\r\n *\r\n * @example\r\n * function compareNumbers(a, b) {\r\n *     return a - b;\r\n * }\r\n */\r\nexport default Queue;\r\n","import ArcType from \"./ArcType.js\";\r\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryPipeline from \"./GeometryPipeline.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Queue from \"./Queue.js\";\r\nimport WindingOrder from \"./WindingOrder.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nconst PolygonGeometryLibrary = {};\r\n\r\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\r\n  polygonHierarchy,\r\n  CartesianX\r\n) {\r\n  let numComponents = 0;\r\n  const stack = [polygonHierarchy];\r\n  while (stack.length > 0) {\r\n    const hierarchy = stack.pop();\r\n    if (!defined(hierarchy)) {\r\n      continue;\r\n    }\r\n\r\n    numComponents += 2;\r\n\r\n    const positions = hierarchy.positions;\r\n    const holes = hierarchy.holes;\r\n\r\n    if (defined(positions) && positions.length > 0) {\r\n      numComponents += positions.length * CartesianX.packedLength;\r\n    }\r\n\r\n    if (defined(holes)) {\r\n      const length = holes.length;\r\n      for (let i = 0; i < length; ++i) {\r\n        stack.push(holes[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return numComponents;\r\n};\r\n\r\nPolygonGeometryLibrary.packPolygonHierarchy = function (\r\n  polygonHierarchy,\r\n  array,\r\n  startingIndex,\r\n  CartesianX\r\n) {\r\n  const stack = [polygonHierarchy];\r\n  while (stack.length > 0) {\r\n    const hierarchy = stack.pop();\r\n    if (!defined(hierarchy)) {\r\n      continue;\r\n    }\r\n\r\n    const positions = hierarchy.positions;\r\n    const holes = hierarchy.holes;\r\n\r\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\r\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\r\n\r\n    if (defined(positions)) {\r\n      const positionsLength = positions.length;\r\n      for (\r\n        let i = 0;\r\n        i < positionsLength;\r\n        ++i, startingIndex += CartesianX.packedLength\r\n      ) {\r\n        CartesianX.pack(positions[i], array, startingIndex);\r\n      }\r\n    }\r\n\r\n    if (defined(holes)) {\r\n      const holesLength = holes.length;\r\n      for (let j = 0; j < holesLength; ++j) {\r\n        stack.push(holes[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return startingIndex;\r\n};\r\n\r\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\r\n  array,\r\n  startingIndex,\r\n  CartesianX\r\n) {\r\n  const positionsLength = array[startingIndex++];\r\n  const holesLength = array[startingIndex++];\r\n\r\n  const positions = new Array(positionsLength);\r\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\r\n\r\n  for (\r\n    let i = 0;\r\n    i < positionsLength;\r\n    ++i, startingIndex += CartesianX.packedLength\r\n  ) {\r\n    positions[i] = CartesianX.unpack(array, startingIndex);\r\n  }\r\n\r\n  for (let j = 0; j < holesLength; ++j) {\r\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n      array,\r\n      startingIndex,\r\n      CartesianX\r\n    );\r\n    startingIndex = holes[j].startingIndex;\r\n    delete holes[j].startingIndex;\r\n  }\r\n\r\n  return {\r\n    positions: positions,\r\n    holes: holes,\r\n    startingIndex: startingIndex,\r\n  };\r\n};\r\n\r\nconst distance2DScratch = new Cartesian2();\r\nfunction getPointAtDistance2D(p0, p1, distance, length) {\r\n  Cartesian2.subtract(p1, p0, distance2DScratch);\r\n  Cartesian2.multiplyByScalar(\r\n    distance2DScratch,\r\n    distance / length,\r\n    distance2DScratch\r\n  );\r\n  Cartesian2.add(p0, distance2DScratch, distance2DScratch);\r\n  return [distance2DScratch.x, distance2DScratch.y];\r\n}\r\n\r\nconst distanceScratch = new Cartesian3();\r\nfunction getPointAtDistance(p0, p1, distance, length) {\r\n  Cartesian3.subtract(p1, p0, distanceScratch);\r\n  Cartesian3.multiplyByScalar(\r\n    distanceScratch,\r\n    distance / length,\r\n    distanceScratch\r\n  );\r\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\r\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\r\n}\r\n\r\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\r\n  const distance = Cartesian3.distance(p0, p1);\r\n  const n = distance / minDistance;\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  return Math.pow(2, countDivide);\r\n};\r\n\r\nconst scratchCartographic0 = new Cartographic();\r\nconst scratchCartographic1 = new Cartographic();\r\nconst scratchCartographic2 = new Cartographic();\r\nconst scratchCartesian0 = new Cartesian3();\r\nconst scratchRhumbLine = new EllipsoidRhumbLine();\r\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\r\n  ellipsoid,\r\n  p0,\r\n  p1,\r\n  minDistance\r\n) {\r\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\r\n  const n = rhumb.surfaceDistance / minDistance;\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  return Math.pow(2, countDivide);\r\n};\r\n\r\n/**\r\n * Subdivides texture coordinates based on the subdivision of the associated world positions.\r\n *\r\n * @param {Cartesian2} t0 First texture coordinate.\r\n * @param {Cartesian2} t1 Second texture coordinate.\r\n * @param {Cartesian3} p0 First world position.\r\n * @param {Cartesian3} p1 Second world position.\r\n * @param {Number} minDistance Minimum distance for a segment.\r\n * @param {Array<Cartesian2>} result The subdivided texture coordinates.\r\n *\r\n * @private\r\n */\r\nPolygonGeometryLibrary.subdivideTexcoordLine = function (\r\n  t0,\r\n  t1,\r\n  p0,\r\n  p1,\r\n  minDistance,\r\n  result\r\n) {\r\n  // Compute the number of subdivisions.\r\n  const subdivisions = PolygonGeometryLibrary.subdivideLineCount(\r\n    p0,\r\n    p1,\r\n    minDistance\r\n  );\r\n\r\n  // Compute the distance between each subdivided point.\r\n  const length2D = Cartesian2.distance(t0, t1);\r\n  const distanceBetweenCoords = length2D / subdivisions;\r\n\r\n  // Resize the result array.\r\n  const texcoords = result;\r\n  texcoords.length = subdivisions * 2;\r\n\r\n  // Compute texture coordinates using linear interpolation.\r\n  let index = 0;\r\n  for (let i = 0; i < subdivisions; i++) {\r\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\r\n    texcoords[index++] = t[0];\r\n    texcoords[index++] = t[1];\r\n  }\r\n\r\n  return texcoords;\r\n};\r\n\r\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\r\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(\r\n    p0,\r\n    p1,\r\n    minDistance\r\n  );\r\n  const length = Cartesian3.distance(p0, p1);\r\n  const distanceBetweenVertices = length / numVertices;\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n\r\n  const positions = result;\r\n  positions.length = numVertices * 3;\r\n\r\n  let index = 0;\r\n  for (let i = 0; i < numVertices; i++) {\r\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\r\n    positions[index++] = p[0];\r\n    positions[index++] = p[1];\r\n    positions[index++] = p[2];\r\n  }\r\n\r\n  return positions;\r\n};\r\n\r\n/**\r\n * Subdivides texture coordinates based on the subdivision of the associated world positions using a rhumb line.\r\n *\r\n * @param {Cartesian2} t0 First texture coordinate.\r\n * @param {Cartesian2} t1 Second texture coordinate.\r\n * @param {Ellipsoid} ellipsoid The ellipsoid.\r\n * @param {Cartesian3} p0 First world position.\r\n * @param {Cartesian3} p1 Second world position.\r\n * @param {Number} minDistance Minimum distance for a segment.\r\n * @param {Array<Cartesian2>} result The subdivided texture coordinates.\r\n *\r\n * @private\r\n */\r\nPolygonGeometryLibrary.subdivideTexcoordRhumbLine = function (\r\n  t0,\r\n  t1,\r\n  ellipsoid,\r\n  p0,\r\n  p1,\r\n  minDistance,\r\n  result\r\n) {\r\n  // Compute the surface distance.\r\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n  scratchRhumbLine.setEndPoints(c0, c1);\r\n  const n = scratchRhumbLine.surfaceDistance / minDistance;\r\n\r\n  // Compute the number of subdivisions.\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  const subdivisions = Math.pow(2, countDivide);\r\n\r\n  // Compute the distance between each subdivided point.\r\n  const length2D = Cartesian2.distance(t0, t1);\r\n  const distanceBetweenCoords = length2D / subdivisions;\r\n\r\n  // Resize the result array.\r\n  const texcoords = result;\r\n  texcoords.length = subdivisions * 2;\r\n\r\n  // Compute texture coordinates using linear interpolation.\r\n  let index = 0;\r\n  for (let i = 0; i < subdivisions; i++) {\r\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\r\n    texcoords[index++] = t[0];\r\n    texcoords[index++] = t[1];\r\n  }\r\n\r\n  return texcoords;\r\n};\r\n\r\nPolygonGeometryLibrary.subdivideRhumbLine = function (\r\n  ellipsoid,\r\n  p0,\r\n  p1,\r\n  minDistance,\r\n  result\r\n) {\r\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\r\n\r\n  const n = rhumb.surfaceDistance / minDistance;\r\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n  const numVertices = Math.pow(2, countDivide);\r\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n\r\n  const positions = result;\r\n  positions.length = numVertices * 3;\r\n\r\n  let index = 0;\r\n  for (let i = 0; i < numVertices; i++) {\r\n    const c = rhumb.interpolateUsingSurfaceDistance(\r\n      i * distanceBetweenVertices,\r\n      scratchCartographic2\r\n    );\r\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\r\n    positions[index++] = p.x;\r\n    positions[index++] = p.y;\r\n    positions[index++] = p.z;\r\n  }\r\n\r\n  return positions;\r\n};\r\n\r\nconst scaleToGeodeticHeightN1 = new Cartesian3();\r\nconst scaleToGeodeticHeightN2 = new Cartesian3();\r\nconst scaleToGeodeticHeightP1 = new Cartesian3();\r\nconst scaleToGeodeticHeightP2 = new Cartesian3();\r\n\r\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\r\n  geometry,\r\n  maxHeight,\r\n  minHeight,\r\n  ellipsoid,\r\n  perPositionHeight\r\n) {\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  const n1 = scaleToGeodeticHeightN1;\r\n  let n2 = scaleToGeodeticHeightN2;\r\n  const p = scaleToGeodeticHeightP1;\r\n  let p2 = scaleToGeodeticHeightP2;\r\n\r\n  if (\r\n    defined(geometry) &&\r\n    defined(geometry.attributes) &&\r\n    defined(geometry.attributes.position)\r\n  ) {\r\n    const positions = geometry.attributes.position.values;\r\n    const length = positions.length / 2;\r\n\r\n    for (let i = 0; i < length; i += 3) {\r\n      Cartesian3.fromArray(positions, i, p);\r\n\r\n      ellipsoid.geodeticSurfaceNormal(p, n1);\r\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\r\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\r\n      n2 = Cartesian3.add(p2, n2, n2);\r\n      positions[i + length] = n2.x;\r\n      positions[i + 1 + length] = n2.y;\r\n      positions[i + 2 + length] = n2.z;\r\n\r\n      if (perPositionHeight) {\r\n        p2 = Cartesian3.clone(p, p2);\r\n      }\r\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\r\n      n2 = Cartesian3.add(p2, n2, n2);\r\n      positions[i] = n2.x;\r\n      positions[i + 1] = n2.y;\r\n      positions[i + 2] = n2.z;\r\n    }\r\n  }\r\n  return geometry;\r\n};\r\n\r\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\r\n  polygonHierarchy,\r\n  scaleToEllipsoidSurface,\r\n  ellipsoid\r\n) {\r\n  // create from a polygon hierarchy\r\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\r\n  const polygons = [];\r\n  const queue = new Queue();\r\n  queue.enqueue(polygonHierarchy);\r\n  let i;\r\n  let j;\r\n  let length;\r\n  while (queue.length !== 0) {\r\n    const outerNode = queue.dequeue();\r\n    let outerRing = outerNode.positions;\r\n    if (scaleToEllipsoidSurface) {\r\n      length = outerRing.length;\r\n      for (i = 0; i < length; i++) {\r\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\r\n      }\r\n    }\r\n    outerRing = arrayRemoveDuplicates(\r\n      outerRing,\r\n      Cartesian3.equalsEpsilon,\r\n      true\r\n    );\r\n    if (outerRing.length < 3) {\r\n      continue;\r\n    }\r\n\r\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\r\n    // The outer polygon contains inner polygons\r\n    for (i = 0; i < numChildren; i++) {\r\n      const hole = outerNode.holes[i];\r\n      let holePositions = hole.positions;\r\n      if (scaleToEllipsoidSurface) {\r\n        length = holePositions.length;\r\n        for (j = 0; j < length; ++j) {\r\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\r\n        }\r\n      }\r\n      holePositions = arrayRemoveDuplicates(\r\n        holePositions,\r\n        Cartesian3.equalsEpsilon,\r\n        true\r\n      );\r\n      if (holePositions.length < 3) {\r\n        continue;\r\n      }\r\n      polygons.push(holePositions);\r\n\r\n      let numGrandchildren = 0;\r\n      if (defined(hole.holes)) {\r\n        numGrandchildren = hole.holes.length;\r\n      }\r\n\r\n      for (j = 0; j < numGrandchildren; j++) {\r\n        queue.enqueue(hole.holes[j]);\r\n      }\r\n    }\r\n\r\n    polygons.push(outerRing);\r\n  }\r\n\r\n  return polygons;\r\n};\r\n\r\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\r\n  polygonHierarchy,\r\n  keepDuplicates,\r\n  projectPointsTo2D,\r\n  scaleToEllipsoidSurface,\r\n  ellipsoid\r\n) {\r\n  // create from a polygon hierarchy\r\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\r\n  const hierarchy = [];\r\n  const polygons = [];\r\n\r\n  const queue = new Queue();\r\n  queue.enqueue(polygonHierarchy);\r\n\r\n  while (queue.length !== 0) {\r\n    const outerNode = queue.dequeue();\r\n    let outerRing = outerNode.positions;\r\n    const holes = outerNode.holes;\r\n\r\n    let i;\r\n    let length;\r\n    if (scaleToEllipsoidSurface) {\r\n      length = outerRing.length;\r\n      for (i = 0; i < length; i++) {\r\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\r\n      }\r\n    }\r\n\r\n    if (!keepDuplicates) {\r\n      outerRing = arrayRemoveDuplicates(\r\n        outerRing,\r\n        Cartesian3.equalsEpsilon,\r\n        true\r\n      );\r\n    }\r\n    if (outerRing.length < 3) {\r\n      continue;\r\n    }\r\n\r\n    let positions2D = projectPointsTo2D(outerRing);\r\n    if (!defined(positions2D)) {\r\n      continue;\r\n    }\r\n    const holeIndices = [];\r\n\r\n    let originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\r\n      positions2D\r\n    );\r\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n      positions2D.reverse();\r\n      outerRing = outerRing.slice().reverse();\r\n    }\r\n\r\n    let positions = outerRing.slice();\r\n    const numChildren = defined(holes) ? holes.length : 0;\r\n    const polygonHoles = [];\r\n    let j;\r\n\r\n    for (i = 0; i < numChildren; i++) {\r\n      const hole = holes[i];\r\n      let holePositions = hole.positions;\r\n      if (scaleToEllipsoidSurface) {\r\n        length = holePositions.length;\r\n        for (j = 0; j < length; ++j) {\r\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\r\n        }\r\n      }\r\n\r\n      if (!keepDuplicates) {\r\n        holePositions = arrayRemoveDuplicates(\r\n          holePositions,\r\n          Cartesian3.equalsEpsilon,\r\n          true\r\n        );\r\n      }\r\n      if (holePositions.length < 3) {\r\n        continue;\r\n      }\r\n\r\n      const holePositions2D = projectPointsTo2D(holePositions);\r\n      if (!defined(holePositions2D)) {\r\n        continue;\r\n      }\r\n\r\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\r\n        holePositions2D\r\n      );\r\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n        holePositions2D.reverse();\r\n        holePositions = holePositions.slice().reverse();\r\n      }\r\n\r\n      polygonHoles.push(holePositions);\r\n      holeIndices.push(positions.length);\r\n      positions = positions.concat(holePositions);\r\n      positions2D = positions2D.concat(holePositions2D);\r\n\r\n      let numGrandchildren = 0;\r\n      if (defined(hole.holes)) {\r\n        numGrandchildren = hole.holes.length;\r\n      }\r\n\r\n      for (j = 0; j < numGrandchildren; j++) {\r\n        queue.enqueue(hole.holes[j]);\r\n      }\r\n    }\r\n\r\n    hierarchy.push({\r\n      outerRing: outerRing,\r\n      holes: polygonHoles,\r\n    });\r\n    polygons.push({\r\n      positions: positions,\r\n      positions2D: positions2D,\r\n      holes: holeIndices,\r\n    });\r\n  }\r\n\r\n  return {\r\n    hierarchy: hierarchy,\r\n    polygons: polygons,\r\n  };\r\n};\r\n\r\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\r\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\r\nconst computeBoundingRectangleQuaternion = new Quaternion();\r\nconst computeBoundingRectangleMatrix3 = new Matrix3();\r\nPolygonGeometryLibrary.computeBoundingRectangle = function (\r\n  planeNormal,\r\n  projectPointTo2D,\r\n  positions,\r\n  angle,\r\n  result\r\n) {\r\n  const rotation = Quaternion.fromAxisAngle(\r\n    planeNormal,\r\n    angle,\r\n    computeBoundingRectangleQuaternion\r\n  );\r\n  const textureMatrix = Matrix3.fromQuaternion(\r\n    rotation,\r\n    computeBoundingRectangleMatrix3\r\n  );\r\n\r\n  let minX = Number.POSITIVE_INFINITY;\r\n  let maxX = Number.NEGATIVE_INFINITY;\r\n  let minY = Number.POSITIVE_INFINITY;\r\n  let maxY = Number.NEGATIVE_INFINITY;\r\n\r\n  const length = positions.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    const p = Cartesian3.clone(\r\n      positions[i],\r\n      computeBoundingRectangleCartesian3\r\n    );\r\n    Matrix3.multiplyByVector(textureMatrix, p, p);\r\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\r\n\r\n    if (defined(st)) {\r\n      minX = Math.min(minX, st.x);\r\n      maxX = Math.max(maxX, st.x);\r\n\r\n      minY = Math.min(minY, st.y);\r\n      maxY = Math.max(maxY, st.y);\r\n    }\r\n  }\r\n\r\n  result.x = minX;\r\n  result.y = minY;\r\n  result.width = maxX - minX;\r\n  result.height = maxY - minY;\r\n  return result;\r\n};\r\n\r\nPolygonGeometryLibrary.createGeometryFromPositions = function (\r\n  ellipsoid,\r\n  polygon,\r\n  textureCoordinates,\r\n  granularity,\r\n  perPositionHeight,\r\n  vertexFormat,\r\n  arcType\r\n) {\r\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\r\n\r\n  /* If polygon is completely unrenderable, just use the first three vertices */\r\n  if (indices.length < 3) {\r\n    indices = [0, 1, 2];\r\n  }\r\n\r\n  const positions = polygon.positions;\r\n\r\n  const hasTexcoords = defined(textureCoordinates);\r\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\r\n\r\n  if (perPositionHeight) {\r\n    const length = positions.length;\r\n    const flattenedPositions = new Array(length * 3);\r\n    let index = 0;\r\n    for (let i = 0; i < length; i++) {\r\n      const p = positions[i];\r\n      flattenedPositions[index++] = p.x;\r\n      flattenedPositions[index++] = p.y;\r\n      flattenedPositions[index++] = p.z;\r\n    }\r\n\r\n    const geometryOptions = {\r\n      attributes: {\r\n        position: new GeometryAttribute({\r\n          componentDatatype: ComponentDatatype.DOUBLE,\r\n          componentsPerAttribute: 3,\r\n          values: flattenedPositions,\r\n        }),\r\n      },\r\n      indices: indices,\r\n      primitiveType: PrimitiveType.TRIANGLES,\r\n    };\r\n\r\n    if (hasTexcoords) {\r\n      geometryOptions.attributes.st = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 2,\r\n        values: Cartesian2.packArray(texcoords),\r\n      });\r\n    }\r\n\r\n    const geometry = new Geometry(geometryOptions);\r\n\r\n    if (vertexFormat.normal) {\r\n      return GeometryPipeline.computeNormal(geometry);\r\n    }\r\n\r\n    return geometry;\r\n  }\r\n\r\n  if (arcType === ArcType.GEODESIC) {\r\n    return PolygonPipeline.computeSubdivision(\r\n      ellipsoid,\r\n      positions,\r\n      indices,\r\n      texcoords,\r\n      granularity\r\n    );\r\n  } else if (arcType === ArcType.RHUMB) {\r\n    return PolygonPipeline.computeRhumbLineSubdivision(\r\n      ellipsoid,\r\n      positions,\r\n      indices,\r\n      texcoords,\r\n      granularity\r\n    );\r\n  }\r\n};\r\n\r\nconst computeWallTexcoordsSubdivided = [];\r\nconst computeWallIndicesSubdivided = [];\r\nconst p1Scratch = new Cartesian3();\r\nconst p2Scratch = new Cartesian3();\r\n\r\nPolygonGeometryLibrary.computeWallGeometry = function (\r\n  positions,\r\n  textureCoordinates,\r\n  ellipsoid,\r\n  granularity,\r\n  perPositionHeight,\r\n  arcType\r\n) {\r\n  let edgePositions;\r\n  let topEdgeLength;\r\n  let i;\r\n  let p1;\r\n  let p2;\r\n  let t1;\r\n  let t2;\r\n  let edgeTexcoords;\r\n  let topEdgeTexcoordLength;\r\n\r\n  let length = positions.length;\r\n  let index = 0;\r\n  let textureIndex = 0;\r\n\r\n  const hasTexcoords = defined(textureCoordinates);\r\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\r\n\r\n  if (!perPositionHeight) {\r\n    const minDistance = CesiumMath.chordLength(\r\n      granularity,\r\n      ellipsoid.maximumRadius\r\n    );\r\n\r\n    let numVertices = 0;\r\n    if (arcType === ArcType.GEODESIC) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    } else if (arcType === ArcType.RHUMB) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\r\n          ellipsoid,\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    }\r\n\r\n    topEdgeLength = (numVertices + length) * 3;\r\n    edgePositions = new Array(topEdgeLength * 2);\r\n\r\n    if (hasTexcoords) {\r\n      topEdgeTexcoordLength = (numVertices + length) * 2;\r\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\r\n    }\r\n\r\n    for (i = 0; i < length; i++) {\r\n      p1 = positions[i];\r\n      p2 = positions[(i + 1) % length];\r\n\r\n      let tempPositions;\r\n      let tempTexcoords;\r\n\r\n      if (hasTexcoords) {\r\n        t1 = texcoords[i];\r\n        t2 = texcoords[(i + 1) % length];\r\n      }\r\n\r\n      if (arcType === ArcType.GEODESIC) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\r\n          p1,\r\n          p2,\r\n          minDistance,\r\n          computeWallIndicesSubdivided\r\n        );\r\n        if (hasTexcoords) {\r\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordLine(\r\n            t1,\r\n            t2,\r\n            p1,\r\n            p2,\r\n            minDistance,\r\n            computeWallTexcoordsSubdivided\r\n          );\r\n        }\r\n      } else if (arcType === ArcType.RHUMB) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\r\n          ellipsoid,\r\n          p1,\r\n          p2,\r\n          minDistance,\r\n          computeWallIndicesSubdivided\r\n        );\r\n        if (hasTexcoords) {\r\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordRhumbLine(\r\n            t1,\r\n            t2,\r\n            ellipsoid,\r\n            p1,\r\n            p2,\r\n            minDistance,\r\n            computeWallTexcoordsSubdivided\r\n          );\r\n        }\r\n      }\r\n      const tempPositionsLength = tempPositions.length;\r\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\r\n        edgePositions[index] = tempPositions[j];\r\n        edgePositions[index + topEdgeLength] = tempPositions[j];\r\n      }\r\n\r\n      edgePositions[index] = p2.x;\r\n      edgePositions[index + topEdgeLength] = p2.x;\r\n      ++index;\r\n\r\n      edgePositions[index] = p2.y;\r\n      edgePositions[index + topEdgeLength] = p2.y;\r\n      ++index;\r\n\r\n      edgePositions[index] = p2.z;\r\n      edgePositions[index + topEdgeLength] = p2.z;\r\n      ++index;\r\n\r\n      if (hasTexcoords) {\r\n        const tempTexcoordsLength = tempTexcoords.length;\r\n        for (let k = 0; k < tempTexcoordsLength; ++k, ++textureIndex) {\r\n          edgeTexcoords[textureIndex] = tempTexcoords[k];\r\n          edgeTexcoords[textureIndex + topEdgeTexcoordLength] =\r\n            tempTexcoords[k];\r\n        }\r\n\r\n        edgeTexcoords[textureIndex] = t2.x;\r\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\r\n        ++textureIndex;\r\n\r\n        edgeTexcoords[textureIndex] = t2.y;\r\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\r\n        ++textureIndex;\r\n      }\r\n    }\r\n  } else {\r\n    topEdgeLength = length * 3 * 2;\r\n    edgePositions = new Array(topEdgeLength * 2);\r\n\r\n    if (hasTexcoords) {\r\n      topEdgeTexcoordLength = length * 2 * 2;\r\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\r\n    }\r\n\r\n    for (i = 0; i < length; i++) {\r\n      p1 = positions[i];\r\n      p2 = positions[(i + 1) % length];\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\r\n      ++index;\r\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\r\n      ++index;\r\n\r\n      if (hasTexcoords) {\r\n        t1 = texcoords[i];\r\n        t2 = texcoords[(i + 1) % length];\r\n        edgeTexcoords[textureIndex] = edgeTexcoords[\r\n          textureIndex + topEdgeTexcoordLength\r\n        ] = t1.x;\r\n        ++textureIndex;\r\n        edgeTexcoords[textureIndex] = edgeTexcoords[\r\n          textureIndex + topEdgeTexcoordLength\r\n        ] = t1.y;\r\n        ++textureIndex;\r\n        edgeTexcoords[textureIndex] = edgeTexcoords[\r\n          textureIndex + topEdgeTexcoordLength\r\n        ] = t2.x;\r\n        ++textureIndex;\r\n        edgeTexcoords[textureIndex] = edgeTexcoords[\r\n          textureIndex + topEdgeTexcoordLength\r\n        ] = t2.y;\r\n        ++textureIndex;\r\n      }\r\n    }\r\n  }\r\n\r\n  length = edgePositions.length;\r\n  const indices = IndexDatatype.createTypedArray(\r\n    length / 3,\r\n    length - positions.length * 6\r\n  );\r\n  let edgeIndex = 0;\r\n  length /= 6;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    const UL = i;\r\n    const UR = UL + 1;\r\n    const LL = UL + length;\r\n    const LR = LL + 1;\r\n\r\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\r\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\r\n    if (\r\n      Cartesian3.equalsEpsilon(\r\n        p1,\r\n        p2,\r\n        CesiumMath.EPSILON10,\r\n        CesiumMath.EPSILON10\r\n      )\r\n    ) {\r\n      //skip corner\r\n      continue;\r\n    }\r\n\r\n    indices[edgeIndex++] = UL;\r\n    indices[edgeIndex++] = LL;\r\n    indices[edgeIndex++] = UR;\r\n    indices[edgeIndex++] = UR;\r\n    indices[edgeIndex++] = LL;\r\n    indices[edgeIndex++] = LR;\r\n  }\r\n\r\n  const geometryOptions = {\r\n    attributes: new GeometryAttributes({\r\n      position: new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.DOUBLE,\r\n        componentsPerAttribute: 3,\r\n        values: edgePositions,\r\n      }),\r\n    }),\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n  };\r\n\r\n  if (hasTexcoords) {\r\n    geometryOptions.attributes.st = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: edgeTexcoords,\r\n    });\r\n  }\r\n\r\n  const geometry = new Geometry(geometryOptions);\r\n\r\n  return geometry;\r\n};\r\nexport default PolygonGeometryLibrary;\r\n"],"names":["Queue","this","_array","_offset","_length","Object","defineProperties","prototype","length","get","enqueue","item","push","dequeue","array","offset","undefined","slice","peek","contains","indexOf","clear","sort","compareFunction","PolygonGeometryLibrary","polygonHierarchy","CartesianX","numComponents","stack","hierarchy","pop","defined","positions","holes","packedLength","i","startingIndex","positionsLength","pack","holesLength","j","Array","unpack","unpackPolygonHierarchy","distance2DScratch","Cartesian2","getPointAtDistance2D","p0","p1","distance","subtract","multiplyByScalar","add","x","y","distanceScratch","Cartesian3","getPointAtDistance","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","CesiumMath","log2","pow","scratchCartographic0","Cartographic","scratchCartographic1","scratchCartographic2","scratchCartesian0","scratchRhumbLine","EllipsoidRhumbLine","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","surfaceDistance","subdivideTexcoordLine","t0","t1","result","subdivisions","length2D","distanceBetweenCoords","texcoords","index","t","subdivideLine","numVertices","distanceBetweenVertices","p","subdivideTexcoordRhumbLine","setEndPoints","subdivideRhumbLine","rhumb","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","defaultValue","Ellipsoid","WGS84","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","outerNode","outerRing","arrayRemoveDuplicates","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","polygonsFromHierarchy","keepDuplicates","projectPointsTo2D","positions2D","holeIndices","originalWindingOrder","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","Quaternion","computeBoundingRectangleMatrix3","Matrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","min","width","height","createGeometryFromPositions","polygon","textureCoordinates","granularity","vertexFormat","arcType","indices","triangulate","hasTexcoords","flattenedPositions","geometryOptions","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","primitiveType","PrimitiveType","TRIANGLES","FLOAT","packArray","Geometry","normal","GeometryPipeline","computeNormal","ArcType","GEODESIC","computeSubdivision","RHUMB","computeRhumbLineSubdivision","computeWallTexcoordsSubdivided","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","t2","edgeTexcoords","topEdgeTexcoordLength","textureIndex","chordLength","maximumRadius","tempPositions","tempTexcoords","tempPositionsLength","tempTexcoordsLength","k","IndexDatatype","createTypedArray","edgeIndex","UL","UR","LL","LR","EPSILON10","GeometryAttributes"],"mappings":"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"}