/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix2-5bde29de","./defaultValue-ac2201bb","./RuntimeError-d45af186","./EllipsoidGeodesic-dedaf218","./EllipsoidRhumbLine-bfb4fa95","./IntersectionTests-0d91a773","./ComponentDatatype-164c57e1","./Plane-3ad20be7"],(function(e,t,n,a,i,r,o,s,c){"use strict";const l={numberOfPoints:function(e,n,a){const i=t.Cartesian3.distance(e,n);return Math.ceil(i/a)},numberOfPointsRhumbLine:function(e,t,n){const a=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(a/(n*n))))}},u=new t.Cartographic;l.extractHeights=function(e,t){const n=e.length,a=new Array(n);for(let i=0;i<n;i++){const n=e[i];a[i]=t.cartesianToCartographic(n,u).height}return a};const h=new t.Matrix4,f=new t.Cartesian3,d=new t.Cartesian3,p=new c.Plane(t.Cartesian3.UNIT_X,0),g=new t.Cartesian3,C=new c.Plane(t.Cartesian3.UNIT_X,0),m=new t.Cartesian3,w=new t.Cartesian3,P=[];function T(e,t,n){const a=P;let i;if(a.length=e,t===n){for(i=0;i<e;i++)a[i]=t;return a}const r=(n-t)/e;for(i=0;i<e;i++){const e=t+i*r;a[i]=e}return a}const y=new t.Cartographic,E=new t.Cartographic,b=new t.Cartesian3,A=new t.Cartesian3,R=new t.Cartesian3,D=new i.EllipsoidGeodesic;let M=new r.EllipsoidRhumbLine;function S(e,n,a,i,r,o,s,c){const u=i.scaleToGeodeticSurface(e,A),h=i.scaleToGeodeticSurface(n,R),f=l.numberOfPoints(e,n,a),d=i.cartesianToCartographic(u,y),p=i.cartesianToCartographic(h,E),g=T(f,r,o);D.setEndPoints(d,p);const C=D.surfaceDistance/f;let m=c;d.height=r;let w=i.cartographicToCartesian(d,b);t.Cartesian3.pack(w,s,m),m+=3;for(let e=1;e<f;e++){const n=D.interpolateUsingSurfaceDistance(e*C,E);n.height=g[e],w=i.cartographicToCartesian(n,b),t.Cartesian3.pack(w,s,m),m+=3}return m}function x(e,n,a,i,o,s,c,u){const h=i.cartesianToCartographic(e,y),f=i.cartesianToCartographic(n,E),d=l.numberOfPointsRhumbLine(h,f,a);h.height=0,f.height=0;const p=T(d,o,s);M.ellipsoid.equals(i)||(M=new r.EllipsoidRhumbLine(void 0,void 0,i)),M.setEndPoints(h,f);const g=M.surfaceDistance/d;let C=u;h.height=o;let m=i.cartographicToCartesian(h,b);t.Cartesian3.pack(m,c,C),C+=3;for(let e=1;e<d;e++){const n=M.interpolateUsingSurfaceDistance(e*g,E);n.height=p[e],m=i.cartographicToCartesian(n,b),t.Cartesian3.pack(m,c,C),C+=3}return C}l.wrapLongitude=function(e,a){const i=[],r=[];if(n.defined(e)&&e.length>0){a=n.defaultValue(a,t.Matrix4.IDENTITY);const s=t.Matrix4.inverseTransformation(a,h),l=t.Matrix4.multiplyByPoint(s,t.Cartesian3.ZERO,f),u=t.Cartesian3.normalize(t.Matrix4.multiplyByPointAsVector(s,t.Cartesian3.UNIT_Y,d),d),P=c.Plane.fromPointNormal(l,u,p),T=t.Cartesian3.normalize(t.Matrix4.multiplyByPointAsVector(s,t.Cartesian3.UNIT_X,g),g),y=c.Plane.fromPointNormal(l,T,C);let E=1;i.push(t.Cartesian3.clone(e[0]));let b=i[0];const A=e.length;for(let a=1;a<A;++a){const s=e[a];if(c.Plane.getPointDistance(y,b)<0||c.Plane.getPointDistance(y,s)<0){const e=o.IntersectionTests.lineSegmentPlane(b,s,P,m);if(n.defined(e)){const n=t.Cartesian3.multiplyByScalar(u,5e-9,w);c.Plane.getPointDistance(P,b)<0&&t.Cartesian3.negate(n,n),i.push(t.Cartesian3.add(e,n,new t.Cartesian3)),r.push(E+1),t.Cartesian3.negate(n,n),i.push(t.Cartesian3.add(e,n,new t.Cartesian3)),E=1}}i.push(t.Cartesian3.clone(e[a])),E++,b=s}r.push(E)}return{positions:i,lengths:r}},l.generateArc=function(e){n.defined(e)||(e={});const i=e.positions;if(!n.defined(i))throw new a.DeveloperError("options.positions is required.");const r=i.length,o=n.defaultValue(e.ellipsoid,t.Ellipsoid.WGS84);let c=n.defaultValue(e.height,0);const u=Array.isArray(c);if(r<1)return[];if(1===r){const e=o.scaleToGeodeticSurface(i[0],A);if(c=u?c[0]:c,0!==c){const n=o.geodeticSurfaceNormal(e,b);t.Cartesian3.multiplyByScalar(n,c,n),t.Cartesian3.add(e,n,e)}return[e.x,e.y,e.z]}let h=e.minDistance;if(!n.defined(h)){const t=n.defaultValue(e.granularity,s.CesiumMath.RADIANS_PER_DEGREE);h=s.CesiumMath.chordLength(t,o.maximumRadius)}let f,d=0;for(f=0;f<r-1;f++)d+=l.numberOfPoints(i[f],i[f+1],h);const p=3*(d+1),g=new Array(p);let C=0;for(f=0;f<r-1;f++){C=S(i[f],i[f+1],h,o,u?c[f]:c,u?c[f+1]:c,g,C)}P.length=0;const m=i[r-1],w=o.cartesianToCartographic(m,y);w.height=u?c[r-1]:c;const T=o.cartographicToCartesian(w,b);return t.Cartesian3.pack(T,g,p-3),g};const N=new t.Cartographic,G=new t.Cartographic;l.generateRhumbArc=function(e){n.defined(e)||(e={});const i=e.positions;if(!n.defined(i))throw new a.DeveloperError("options.positions is required.");const r=i.length,o=n.defaultValue(e.ellipsoid,t.Ellipsoid.WGS84);let c=n.defaultValue(e.height,0);const u=Array.isArray(c);if(r<1)return[];if(1===r){const e=o.scaleToGeodeticSurface(i[0],A);if(c=u?c[0]:c,0!==c){const n=o.geodeticSurfaceNormal(e,b);t.Cartesian3.multiplyByScalar(n,c,n),t.Cartesian3.add(e,n,e)}return[e.x,e.y,e.z]}const h=n.defaultValue(e.granularity,s.CesiumMath.RADIANS_PER_DEGREE);let f,d,p=0,g=o.cartesianToCartographic(i[0],N);for(f=0;f<r-1;f++)d=o.cartesianToCartographic(i[f+1],G),p+=l.numberOfPointsRhumbLine(g,d,h),g=t.Cartographic.clone(d,N);const C=3*(p+1),m=new Array(C);let w=0;for(f=0;f<r-1;f++){w=x(i[f],i[f+1],h,o,u?c[f]:c,u?c[f+1]:c,m,w)}P.length=0;const T=i[r-1],E=o.cartesianToCartographic(T,y);E.height=u?c[r-1]:c;const R=o.cartographicToCartesian(E,b);return t.Cartesian3.pack(R,m,C-3),m},l.generateCartesianArc=function(e){const n=l.generateArc(e),a=n.length/3,i=new Array(a);for(let e=0;e<a;e++)i[e]=t.Cartesian3.unpack(n,3*e);return i},l.generateCartesianRhumbArc=function(e){const n=l.generateRhumbArc(e),a=n.length/3,i=new Array(a);for(let e=0;e<a;e++)i[e]=t.Cartesian3.unpack(n,3*e);return i},e.PolylinePipeline=l}));
//# sourceMappingURL=PolylinePipeline-01f0ccf8.js.map
