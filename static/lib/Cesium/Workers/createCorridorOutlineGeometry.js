/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./arrayRemoveDuplicates-68f14b2f","./Transforms-3f580a0c","./Matrix2-5bde29de","./RuntimeError-d45af186","./ComponentDatatype-164c57e1","./PolylineVolumeGeometryLibrary-22c14de9","./CorridorGeometryLibrary-e554a7f1","./defaultValue-ac2201bb","./GeometryAttribute-f83e6129","./GeometryAttributes-d060f8b5","./GeometryOffsetAttribute-a17b96d9","./IndexDatatype-4e1ec1a1","./PolygonPipeline-71d5516a","./_commonjsHelpers-3aae1032-ac53d93e","./combine-0dce9b0f","./WebGLConstants-e12cdc8a","./EllipsoidTangentPlane-fa2bc0dc","./AxisAlignedBoundingBox-b2f2975e","./IntersectionTests-0d91a773","./Plane-3ad20be7","./PolylinePipeline-01f0ccf8","./EllipsoidGeodesic-dedaf218","./EllipsoidRhumbLine-bfb4fa95"],(function(e,t,i,o,r,n,s,a,l,d,u,p,f,c,h,y,b,g,m,A,_,C,E){"use strict";const G=new i.Cartesian3,T=new i.Cartesian3,P=new i.Cartesian3;function v(e,t){const o=[],u=e.positions,f=e.corners,c=e.endPositions,h=new d.GeometryAttributes;let y,b,g,m=0,A=0,_=0;for(b=0;b<u.length;b+=2)g=u[b].length-3,m+=g,_+=g/3*4,A+=u[b+1].length-3;for(m+=3,A+=3,b=0;b<f.length;b++){y=f[b];const e=f[b].leftPositions;a.defined(e)?(g=e.length,m+=g,_+=g/3*2):(g=f[b].rightPositions.length,A+=g,_+=g/3*2)}const C=a.defined(c);let E;C&&(E=c[0].length-3,m+=E,A+=E,E/=3,_+=4*E);const v=m+A,w=new Float64Array(v);let L,D,k,O,x,V,H=0,N=v-1;const I=E/2,S=p.IndexDatatype.createTypedArray(v/3,_+4);let B=0;if(S[B++]=H/3,S[B++]=(N-2)/3,C){o.push(H/3),V=G,x=T;const e=c[0];for(b=0;b<I;b++)V=i.Cartesian3.fromArray(e,3*(I-1-b),V),x=i.Cartesian3.fromArray(e,3*(I+b),x),s.CorridorGeometryLibrary.addAttribute(w,x,H),s.CorridorGeometryLibrary.addAttribute(w,V,void 0,N),D=H/3,O=D+1,L=(N-2)/3,k=L-1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3}let M=0,R=u[M++],U=u[M++];for(w.set(R,H),w.set(U,N-U.length+1),g=U.length-3,o.push(H/3,(N-2)/3),b=0;b<g;b+=3)D=H/3,O=D+1,L=(N-2)/3,k=L-1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3;for(b=0;b<f.length;b++){let e;y=f[b];const r=y.leftPositions,l=y.rightPositions;let d,p=P;if(a.defined(r)){for(N-=3,d=k,o.push(O),e=0;e<r.length/3;e++)p=i.Cartesian3.fromArray(r,3*e,p),S[B++]=d-e-1,S[B++]=d-e,s.CorridorGeometryLibrary.addAttribute(w,p,void 0,N),N-=3;o.push(d-Math.floor(r.length/6)),t===n.CornerType.BEVELED&&o.push((N-2)/3+1),H+=3}else{for(H+=3,d=O,o.push(k),e=0;e<l.length/3;e++)p=i.Cartesian3.fromArray(l,3*e,p),S[B++]=d+e,S[B++]=d+e+1,s.CorridorGeometryLibrary.addAttribute(w,p,H),H+=3;o.push(d+Math.floor(l.length/6)),t===n.CornerType.BEVELED&&o.push(H/3-1),N-=3}for(R=u[M++],U=u[M++],R.splice(0,3),U.splice(U.length-3,3),w.set(R,H),w.set(U,N-U.length+1),g=U.length-3,e=0;e<U.length;e+=3)O=H/3,D=O-1,k=(N-2)/3,L=k+1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3;H-=3,N+=3,o.push(H/3,(N-2)/3)}if(C){H+=3,N-=3,V=G,x=T;const e=c[1];for(b=0;b<I;b++)V=i.Cartesian3.fromArray(e,3*(E-b-1),V),x=i.Cartesian3.fromArray(e,3*b,x),s.CorridorGeometryLibrary.addAttribute(w,V,void 0,N),s.CorridorGeometryLibrary.addAttribute(w,x,H),O=H/3,D=O-1,k=(N-2)/3,L=k+1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3;o.push(H/3)}else o.push(H/3,(N-2)/3);return S[B++]=H/3,S[B++]=(N-2)/3,h.position=new l.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),{attributes:h,indices:S,wallIndices:o}}function w(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).positions,s=e.width;o.Check.typeOf.object("options.positions",t),o.Check.typeOf.number("options.width",s);const l=a.defaultValue(e.height,0),d=a.defaultValue(e.extrudedHeight,l);this._positions=t,this._ellipsoid=i.Ellipsoid.clone(a.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84)),this._width=s,this._height=Math.max(l,d),this._extrudedHeight=Math.min(l,d),this._cornerType=a.defaultValue(e.cornerType,n.CornerType.ROUNDED),this._granularity=a.defaultValue(e.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*i.Cartesian3.packedLength+i.Ellipsoid.packedLength+6}w.pack=function(e,t,r){o.Check.typeOf.object("value",e),o.Check.typeOf.object("array",t),r=a.defaultValue(r,0);const n=e._positions,s=n.length;t[r++]=s;for(let e=0;e<s;++e,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(n[e],t,r);return i.Ellipsoid.pack(e._ellipsoid,t,r),r+=i.Ellipsoid.packedLength,t[r++]=e._width,t[r++]=e._height,t[r++]=e._extrudedHeight,t[r++]=e._cornerType,t[r++]=e._granularity,t[r]=a.defaultValue(e._offsetAttribute,-1),t};const L=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),D={positions:void 0,ellipsoid:L,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return w.unpack=function(e,t,r){o.Check.typeOf.object("array",e),t=a.defaultValue(t,0);const n=e[t++],s=new Array(n);for(let o=0;o<n;++o,t+=i.Cartesian3.packedLength)s[o]=i.Cartesian3.unpack(e,t);const l=i.Ellipsoid.unpack(e,t,L);t+=i.Ellipsoid.packedLength;const d=e[t++],u=e[t++],p=e[t++],f=e[t++],c=e[t++],h=e[t];return a.defined(r)?(r._positions=s,r._ellipsoid=i.Ellipsoid.clone(l,r._ellipsoid),r._width=d,r._height=u,r._extrudedHeight=p,r._cornerType=f,r._granularity=c,r._offsetAttribute=-1===h?void 0:h,r):(D.positions=s,D.width=d,D.height=u,D.extrudedHeight=p,D.cornerType=f,D.granularity=c,D.offsetAttribute=-1===h?void 0:h,new w(D))},w.createGeometry=function(o){let n=o._positions;const d=o._width,c=o._ellipsoid;n=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(n,c);const h=e.arrayRemoveDuplicates(n,i.Cartesian3.equalsEpsilon);if(h.length<2||d<=0)return;const y=o._height,b=o._extrudedHeight,g=!r.CesiumMath.equalsEpsilon(y,b,0,r.CesiumMath.EPSILON2),m={ellipsoid:c,positions:h,width:d,cornerType:o._cornerType,granularity:o._granularity,saveAttributes:!1};let A;if(g)m.height=y,m.extrudedHeight=b,m.offsetAttribute=o._offsetAttribute,A=function(e){const t=e.ellipsoid,i=v(s.CorridorGeometryLibrary.computePositions(e),e.cornerType),o=i.wallIndices,n=e.height,d=e.extrudedHeight,c=i.attributes,h=i.indices;let y=c.position.values,b=y.length,g=new Float64Array(b);g.set(y);const m=new Float64Array(2*b);if(y=f.PolygonPipeline.scaleToGeodeticHeight(y,n,t),g=f.PolygonPipeline.scaleToGeodeticHeight(g,d,t),m.set(y),m.set(g,b),c.position.values=m,b/=3,a.defined(e.offsetAttribute)){let t=new Uint8Array(2*b);if(e.offsetAttribute===u.GeometryOffsetAttribute.TOP)t=t.fill(1,0,b);else{const i=e.offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}c.applyOffset=new l.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let A;const _=h.length,C=p.IndexDatatype.createTypedArray(m.length/3,2*(_+o.length));C.set(h);let E,G,T=_;for(A=0;A<_;A+=2){const e=h[A],t=h[A+1];C[T++]=e+b,C[T++]=t+b}for(A=0;A<o.length;A++)E=o[A],G=E+b,C[T++]=E,C[T++]=G;return{attributes:c,indices:C}}(m);else{if(A=v(s.CorridorGeometryLibrary.computePositions(m),m.cornerType),A.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(A.attributes.position.values,y,c),a.defined(o._offsetAttribute)){const e=A.attributes.position.values.length,t=o._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(t);A.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}const _=A.attributes,C=t.BoundingSphere.fromVertices(_.position.values,void 0,3);return new l.Geometry({attributes:_,indices:A.indices,primitiveType:l.PrimitiveType.LINES,boundingSphere:C,offsetAttribute:o._offsetAttribute})},function(e,t){return a.defined(t)&&(e=w.unpack(e,t)),e._ellipsoid=i.Ellipsoid.clone(e._ellipsoid),w.createGeometry(e)}}));
//# sourceMappingURL=createCorridorOutlineGeometry.js.map
