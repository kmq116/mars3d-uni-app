{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport GeographicProjection from \"./GeographicProjection.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\r\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\r\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\r\n *\r\n * @alias GeographicTilingScheme\r\n * @constructor\r\n *\r\n * @param {Object} [options] Object with the following properties:\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\r\n * the WGS84 ellipsoid.\r\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\r\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\r\n * the tile tree.\r\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\r\n * the tile tree.\r\n */\r\nfunction GeographicTilingScheme(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\r\n  this._projection = new GeographicProjection(this._ellipsoid);\r\n  this._numberOfLevelZeroTilesX = defaultValue(\r\n    options.numberOfLevelZeroTilesX,\r\n    2\r\n  );\r\n  this._numberOfLevelZeroTilesY = defaultValue(\r\n    options.numberOfLevelZeroTilesY,\r\n    1\r\n  );\r\n}\r\n\r\nObject.defineProperties(GeographicTilingScheme.prototype, {\r\n  /**\r\n   * Gets the ellipsoid that is tiled by this tiling scheme.\r\n   * @memberof GeographicTilingScheme.prototype\r\n   * @type {Ellipsoid}\r\n   */\r\n  ellipsoid: {\r\n    get: function () {\r\n      return this._ellipsoid;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the rectangle, in radians, covered by this tiling scheme.\r\n   * @memberof GeographicTilingScheme.prototype\r\n   * @type {Rectangle}\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      return this._rectangle;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the map projection used by this tiling scheme.\r\n   * @memberof GeographicTilingScheme.prototype\r\n   * @type {MapProjection}\r\n   */\r\n  projection: {\r\n    get: function () {\r\n      return this._projection;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\r\n *\r\n * @param {Number} level The level-of-detail.\r\n * @returns {Number} The number of tiles in the X direction at the given level.\r\n */\r\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\r\n  return this._numberOfLevelZeroTilesX << level;\r\n};\r\n\r\n/**\r\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\r\n *\r\n * @param {Number} level The level-of-detail.\r\n * @returns {Number} The number of tiles in the Y direction at the given level.\r\n */\r\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\r\n  return this._numberOfLevelZeroTilesY << level;\r\n};\r\n\r\n/**\r\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\r\n * of this tiling scheme.\r\n *\r\n * @param {Rectangle} rectangle The rectangle to transform.\r\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\r\n *          is undefined.\r\n */\r\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\r\n  rectangle,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  const west = CesiumMath.toDegrees(rectangle.west);\r\n  const south = CesiumMath.toDegrees(rectangle.south);\r\n  const east = CesiumMath.toDegrees(rectangle.east);\r\n  const north = CesiumMath.toDegrees(rectangle.north);\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\r\n * of the tiling scheme.\r\n *\r\n * @param {Number} x The integer x coordinate of the tile.\r\n * @param {Number} y The integer y coordinate of the tile.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\r\n  x,\r\n  y,\r\n  level,\r\n  result\r\n) {\r\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\r\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\r\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\r\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\r\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\r\n  return rectangleRadians;\r\n};\r\n\r\n/**\r\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\r\n *\r\n * @param {Number} x The integer x coordinate of the tile.\r\n * @param {Number} y The integer y coordinate of the tile.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\r\n  x,\r\n  y,\r\n  level,\r\n  result\r\n) {\r\n  const rectangle = this._rectangle;\r\n\r\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\r\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n  const xTileWidth = rectangle.width / xTiles;\r\n  const west = x * xTileWidth + rectangle.west;\r\n  const east = (x + 1) * xTileWidth + rectangle.west;\r\n\r\n  const yTileHeight = rectangle.height / yTiles;\r\n  const north = rectangle.north - y * yTileHeight;\r\n  const south = rectangle.north - (y + 1) * yTileHeight;\r\n\r\n  if (!defined(result)) {\r\n    result = new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Calculates the tile x, y coordinates of the tile containing\r\n * a given cartographic position.\r\n *\r\n * @param {Cartographic} position The position.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.positionToTileXY = function (\r\n  position,\r\n  level,\r\n  result\r\n) {\r\n  const rectangle = this._rectangle;\r\n  if (!Rectangle.contains(rectangle, position)) {\r\n    // outside the bounds of the tiling scheme\r\n    return undefined;\r\n  }\r\n\r\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\r\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n  const xTileWidth = rectangle.width / xTiles;\r\n  const yTileHeight = rectangle.height / yTiles;\r\n\r\n  let longitude = position.longitude;\r\n  if (rectangle.east < rectangle.west) {\r\n    longitude += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  let xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\r\n  if (xTileCoordinate >= xTiles) {\r\n    xTileCoordinate = xTiles - 1;\r\n  }\r\n\r\n  let yTileCoordinate =\r\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\r\n  if (yTileCoordinate >= yTiles) {\r\n    yTileCoordinate = yTiles - 1;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\r\n  }\r\n\r\n  result.x = xTileCoordinate;\r\n  result.y = yTileCoordinate;\r\n  return result;\r\n};\r\nexport default GeographicTilingScheme;\r\n","import BoundingSphere from \"./BoundingSphere.js\";\r\nimport buildModuleUrl from \"./buildModuleUrl.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport Resource from \"./Resource.js\";\r\n\r\nconst scratchDiagonalCartesianNE = new Cartesian3();\r\nconst scratchDiagonalCartesianSW = new Cartesian3();\r\nconst scratchDiagonalCartographic = new Cartographic();\r\nconst scratchCenterCartesian = new Cartesian3();\r\nconst scratchSurfaceCartesian = new Cartesian3();\r\n\r\nconst scratchBoundingSphere = new BoundingSphere();\r\nconst tilingScheme = new GeographicTilingScheme();\r\nconst scratchCorners = [\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n];\r\nconst scratchTileXY = new Cartesian2();\r\n\r\n/**\r\n * A collection of functions for approximating terrain height\r\n * @private\r\n */\r\nconst ApproximateTerrainHeights = {};\r\n\r\n/**\r\n * Initializes the minimum and maximum terrain heights\r\n * @return {Promise.<void>}\r\n */\r\nApproximateTerrainHeights.initialize = function () {\r\n  let initPromise = ApproximateTerrainHeights._initPromise;\r\n  if (defined(initPromise)) {\r\n    return initPromise;\r\n  }\r\n\r\n  initPromise = Resource.fetchJson(\r\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\")\r\n  ).then(function (json) {\r\n    ApproximateTerrainHeights._terrainHeights = json;\r\n  });\r\n  ApproximateTerrainHeights._initPromise = initPromise;\r\n\r\n  return initPromise;\r\n};\r\n\r\n/**\r\n * Computes the minimum and maximum terrain heights for a given rectangle\r\n * @param {Rectangle} rectangle The bounding rectangle\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\r\n */\r\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\r\n  rectangle,\r\n  ellipsoid\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"rectangle\", rectangle);\r\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n    throw new DeveloperError(\r\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  const xyLevel = getTileXYLevel(rectangle);\r\n\r\n  // Get the terrain min/max for that tile\r\n  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n  if (defined(xyLevel)) {\r\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\r\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\r\n    if (defined(heights)) {\r\n      minTerrainHeight = heights[0];\r\n      maxTerrainHeight = heights[1];\r\n    }\r\n\r\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\r\n    ellipsoid.cartographicToCartesian(\r\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\r\n      scratchDiagonalCartesianNE\r\n    );\r\n    ellipsoid.cartographicToCartesian(\r\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\r\n      scratchDiagonalCartesianSW\r\n    );\r\n\r\n    Cartesian3.midpoint(\r\n      scratchDiagonalCartesianSW,\r\n      scratchDiagonalCartesianNE,\r\n      scratchCenterCartesian\r\n    );\r\n    const surfacePosition = ellipsoid.scaleToGeodeticSurface(\r\n      scratchCenterCartesian,\r\n      scratchSurfaceCartesian\r\n    );\r\n    if (defined(surfacePosition)) {\r\n      const distance = Cartesian3.distance(\r\n        scratchCenterCartesian,\r\n        surfacePosition\r\n      );\r\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\r\n    } else {\r\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n    }\r\n  }\r\n\r\n  minTerrainHeight = Math.max(\r\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n    minTerrainHeight\r\n  );\r\n\r\n  return {\r\n    minimumTerrainHeight: minTerrainHeight,\r\n    maximumTerrainHeight: maxTerrainHeight,\r\n  };\r\n};\r\n\r\n/**\r\n * Computes the bounding sphere based on the tile heights in the rectangle\r\n * @param {Rectangle} rectangle The bounding rectangle\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n * @return {BoundingSphere} The result bounding sphere\r\n */\r\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"rectangle\", rectangle);\r\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n    throw new DeveloperError(\r\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  const xyLevel = getTileXYLevel(rectangle);\r\n\r\n  // Get the terrain max for that tile\r\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n  if (defined(xyLevel)) {\r\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\r\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\r\n    if (defined(heights)) {\r\n      maxTerrainHeight = heights[1];\r\n    }\r\n  }\r\n\r\n  const result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\r\n  BoundingSphere.fromRectangle3D(\r\n    rectangle,\r\n    ellipsoid,\r\n    maxTerrainHeight,\r\n    scratchBoundingSphere\r\n  );\r\n\r\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\r\n};\r\n\r\nfunction getTileXYLevel(rectangle) {\r\n  Cartographic.fromRadians(\r\n    rectangle.east,\r\n    rectangle.north,\r\n    0.0,\r\n    scratchCorners[0]\r\n  );\r\n  Cartographic.fromRadians(\r\n    rectangle.west,\r\n    rectangle.north,\r\n    0.0,\r\n    scratchCorners[1]\r\n  );\r\n  Cartographic.fromRadians(\r\n    rectangle.east,\r\n    rectangle.south,\r\n    0.0,\r\n    scratchCorners[2]\r\n  );\r\n  Cartographic.fromRadians(\r\n    rectangle.west,\r\n    rectangle.south,\r\n    0.0,\r\n    scratchCorners[3]\r\n  );\r\n\r\n  // Determine which tile the bounding rectangle is in\r\n  let lastLevelX = 0,\r\n    lastLevelY = 0;\r\n  let currentX = 0,\r\n    currentY = 0;\r\n  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\r\n  let i;\r\n  for (i = 0; i <= maxLevel; ++i) {\r\n    let failed = false;\r\n    for (let j = 0; j < 4; ++j) {\r\n      const corner = scratchCorners[j];\r\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\r\n      if (j === 0) {\r\n        currentX = scratchTileXY.x;\r\n        currentY = scratchTileXY.y;\r\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\r\n        failed = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (failed) {\r\n      break;\r\n    }\r\n\r\n    lastLevelX = currentX;\r\n    lastLevelY = currentY;\r\n  }\r\n\r\n  if (i === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return {\r\n    x: lastLevelX,\r\n    y: lastLevelY,\r\n    level: i > maxLevel ? maxLevel : i - 1,\r\n  };\r\n}\r\n\r\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\r\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\r\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\r\nApproximateTerrainHeights._terrainHeights = undefined;\r\nApproximateTerrainHeights._initPromise = undefined;\r\n\r\nObject.defineProperties(ApproximateTerrainHeights, {\r\n  /**\r\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\r\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\r\n   * @type {Boolean}\r\n   * @readonly\r\n   * @memberof ApproximateTerrainHeights\r\n   */\r\n  initialized: {\r\n    get: function () {\r\n      return defined(ApproximateTerrainHeights._terrainHeights);\r\n    },\r\n  },\r\n});\r\nexport default ApproximateTerrainHeights;\r\n","import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\r\nimport ArcType from \"./ArcType.js\";\r\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\r\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\r\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\r\nimport GeographicProjection from \"./GeographicProjection.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport IntersectionTests from \"./IntersectionTests.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\r\n\r\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\r\nconst PROJECTION_COUNT = PROJECTIONS.length;\r\n\r\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\r\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\n// Initial heights for constructing the wall.\r\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\r\n// prevent precision problems with planes in the shader.\r\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n// which is a highly conservative bound, usually puts the plane origin several thousands\r\n// of meters away from the actual terrain, causing floating point problems when checking\r\n// fragments on terrain against the plane.\r\n// Ellipsoid height is generally much closer.\r\n// The initial max height is arbitrary.\r\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\r\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\r\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\r\n\r\n/**\r\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\r\n *\r\n * @alias GroundPolylineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Options with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\r\n * @param {Number} [options.width=1.0] The screen space width in pixels.\r\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\r\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n *\r\n * @exception {DeveloperError} At least two positions are required.\r\n *\r\n * @see GroundPolylinePrimitive\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -112.1340164450331, 36.05494287836128,\r\n *   -112.08821010582645, 36.097804071380715,\r\n *   -112.13296079730024, 36.168769146801104\r\n * ]);\r\n *\r\n * const geometry = new Cesium.GroundPolylineGeometry({\r\n *   positions : positions\r\n * });\r\n */\r\nfunction GroundPolylineGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const positions = options.positions;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(positions) || positions.length < 2) {\r\n    throw new DeveloperError(\"At least two positions are required.\");\r\n  }\r\n  if (\r\n    defined(options.arcType) &&\r\n    options.arcType !== ArcType.GEODESIC &&\r\n    options.arcType !== ArcType.RHUMB\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  /**\r\n   * The screen space width in pixels.\r\n   * @type {Number}\r\n   */\r\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\r\n\r\n  this._positions = positions;\r\n\r\n  /**\r\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\r\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\r\n   * @type {Boolean}\r\n   * @default 9999.0\r\n   */\r\n  this.granularity = defaultValue(options.granularity, 9999.0);\r\n\r\n  /**\r\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n   * If the geometry has two positions this parameter will be ignored.\r\n   * @type {Boolean}\r\n   * @default false\r\n   */\r\n  this.loop = defaultValue(options.loop, false);\r\n\r\n  /**\r\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n   * @type {ArcType}\r\n   * @default ArcType.GEODESIC\r\n   */\r\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n  this._ellipsoid = Ellipsoid.WGS84;\r\n\r\n  // MapProjections can't be packed, so store the index to a known MapProjection.\r\n  this._projectionIndex = 0;\r\n  this._workerName = \"createGroundPolylineGeometry\";\r\n\r\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\r\n  this._scene3DOnly = false;\r\n}\r\n\r\nObject.defineProperties(GroundPolylineGeometry.prototype, {\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @memberof GroundPolylineGeometry.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   * @private\r\n   */\r\n  packedLength: {\r\n    get: function () {\r\n      return (\r\n        1.0 +\r\n        this._positions.length * 3 +\r\n        1.0 +\r\n        1.0 +\r\n        1.0 +\r\n        Ellipsoid.packedLength +\r\n        1.0 +\r\n        1.0\r\n      );\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Set the GroundPolylineGeometry's projection and ellipsoid.\r\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\r\n *\r\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\r\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\r\n * @private\r\n */\r\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\r\n  groundPolylineGeometry,\r\n  mapProjection\r\n) {\r\n  let projectionIndex = 0;\r\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\r\n    if (mapProjection instanceof PROJECTIONS[i]) {\r\n      projectionIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  groundPolylineGeometry._projectionIndex = projectionIndex;\r\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\r\n};\r\n\r\nconst cart3Scratch1 = new Cartesian3();\r\nconst cart3Scratch2 = new Cartesian3();\r\nconst cart3Scratch3 = new Cartesian3();\r\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\r\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\r\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\r\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\r\n\r\n  const up = direction(startTop, startBottom, cart3Scratch2);\r\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\r\n\r\n  Cartesian3.cross(forward, up, result);\r\n  return Cartesian3.normalize(result, result);\r\n}\r\n\r\nconst interpolatedCartographicScratch = new Cartographic();\r\nconst interpolatedBottomScratch = new Cartesian3();\r\nconst interpolatedTopScratch = new Cartesian3();\r\nconst interpolatedNormalScratch = new Cartesian3();\r\nfunction interpolateSegment(\r\n  start,\r\n  end,\r\n  minHeight,\r\n  maxHeight,\r\n  granularity,\r\n  arcType,\r\n  ellipsoid,\r\n  normalsArray,\r\n  bottomPositionsArray,\r\n  topPositionsArray,\r\n  cartographicsArray\r\n) {\r\n  if (granularity === 0.0) {\r\n    return;\r\n  }\r\n\r\n  let ellipsoidLine;\r\n  if (arcType === ArcType.GEODESIC) {\r\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\r\n  } else if (arcType === ArcType.RHUMB) {\r\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\r\n  }\r\n\r\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\r\n  if (surfaceDistance < granularity) {\r\n    return;\r\n  }\r\n\r\n  // Compute rightwards normal applicable at all interpolated points\r\n  const interpolatedNormal = computeRightNormal(\r\n    start,\r\n    end,\r\n    maxHeight,\r\n    ellipsoid,\r\n    interpolatedNormalScratch\r\n  );\r\n\r\n  const segments = Math.ceil(surfaceDistance / granularity);\r\n  const interpointDistance = surfaceDistance / segments;\r\n  let distanceFromStart = interpointDistance;\r\n  const pointsToAdd = segments - 1;\r\n  let packIndex = normalsArray.length;\r\n  for (let i = 0; i < pointsToAdd; i++) {\r\n    const interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(\r\n      distanceFromStart,\r\n      interpolatedCartographicScratch\r\n    );\r\n    const interpolatedBottom = getPosition(\r\n      ellipsoid,\r\n      interpolatedCartographic,\r\n      minHeight,\r\n      interpolatedBottomScratch\r\n    );\r\n    const interpolatedTop = getPosition(\r\n      ellipsoid,\r\n      interpolatedCartographic,\r\n      maxHeight,\r\n      interpolatedTopScratch\r\n    );\r\n\r\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\r\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\r\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\r\n    cartographicsArray.push(interpolatedCartographic.latitude);\r\n    cartographicsArray.push(interpolatedCartographic.longitude);\r\n\r\n    packIndex += 3;\r\n    distanceFromStart += interpointDistance;\r\n  }\r\n}\r\n\r\nconst heightlessCartographicScratch = new Cartographic();\r\nfunction getPosition(ellipsoid, cartographic, height, result) {\r\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\r\n  heightlessCartographicScratch.height = height;\r\n  return Cartographic.toCartesian(\r\n    heightlessCartographicScratch,\r\n    ellipsoid,\r\n    result\r\n  );\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  let index = defaultValue(startingIndex, 0);\r\n\r\n  const positions = value._positions;\r\n  const positionsLength = positions.length;\r\n\r\n  array[index++] = positionsLength;\r\n\r\n  for (let i = 0; i < positionsLength; ++i) {\r\n    const cartesian = positions[i];\r\n    Cartesian3.pack(cartesian, array, index);\r\n    index += 3;\r\n  }\r\n\r\n  array[index++] = value.granularity;\r\n  array[index++] = value.loop ? 1.0 : 0.0;\r\n  array[index++] = value.arcType;\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, index);\r\n  index += Ellipsoid.packedLength;\r\n\r\n  array[index++] = value._projectionIndex;\r\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonGeometry} [result] The object into which to store the result.\r\n */\r\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  let index = defaultValue(startingIndex, 0);\r\n  const positionsLength = array[index++];\r\n  const positions = new Array(positionsLength);\r\n\r\n  for (let i = 0; i < positionsLength; i++) {\r\n    positions[i] = Cartesian3.unpack(array, index);\r\n    index += 3;\r\n  }\r\n\r\n  const granularity = array[index++];\r\n  const loop = array[index++] === 1.0;\r\n  const arcType = array[index++];\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, index);\r\n  index += Ellipsoid.packedLength;\r\n\r\n  const projectionIndex = array[index++];\r\n  const scene3DOnly = array[index++] === 1.0;\r\n\r\n  if (!defined(result)) {\r\n    result = new GroundPolylineGeometry({\r\n      positions: positions,\r\n    });\r\n  }\r\n\r\n  result._positions = positions;\r\n  result.granularity = granularity;\r\n  result.loop = loop;\r\n  result.arcType = arcType;\r\n  result._ellipsoid = ellipsoid;\r\n  result._projectionIndex = projectionIndex;\r\n  result._scene3DOnly = scene3DOnly;\r\n\r\n  return result;\r\n};\r\n\r\nfunction direction(target, origin, result) {\r\n  Cartesian3.subtract(target, origin, result);\r\n  Cartesian3.normalize(result, result);\r\n  return result;\r\n}\r\n\r\nfunction tangentDirection(target, origin, up, result) {\r\n  result = direction(target, origin, result);\r\n\r\n  // orthogonalize\r\n  result = Cartesian3.cross(result, up, result);\r\n  result = Cartesian3.normalize(result, result);\r\n  result = Cartesian3.cross(up, result, result);\r\n  return result;\r\n}\r\n\r\nconst toPreviousScratch = new Cartesian3();\r\nconst toNextScratch = new Cartesian3();\r\nconst forwardScratch = new Cartesian3();\r\nconst vertexUpScratch = new Cartesian3();\r\nconst cosine90 = 0.0;\r\nconst cosine180 = -1.0;\r\nfunction computeVertexMiterNormal(\r\n  previousBottom,\r\n  vertexBottom,\r\n  vertexTop,\r\n  nextBottom,\r\n  result\r\n) {\r\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\r\n\r\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\r\n  const toPrevious = tangentDirection(\r\n    previousBottom,\r\n    vertexBottom,\r\n    up,\r\n    toPreviousScratch\r\n  );\r\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\r\n\r\n  // Check if tangents are almost opposite - if so, no need to miter.\r\n  if (\r\n    CesiumMath.equalsEpsilon(\r\n      Cartesian3.dot(toPrevious, toNext),\r\n      cosine180,\r\n      CesiumMath.EPSILON5\r\n    )\r\n  ) {\r\n    result = Cartesian3.cross(up, toPrevious, result);\r\n    result = Cartesian3.normalize(result, result);\r\n    return result;\r\n  }\r\n\r\n  // Average directions to previous and to next in the plane of Up\r\n  result = Cartesian3.add(toNext, toPrevious, result);\r\n  result = Cartesian3.normalize(result, result);\r\n\r\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\r\n  const forward = Cartesian3.cross(up, result, forwardScratch);\r\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\r\n    result = Cartesian3.negate(result, result);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\nconst previousBottomScratch = new Cartesian3();\r\nconst vertexBottomScratch = new Cartesian3();\r\nconst vertexTopScratch = new Cartesian3();\r\nconst nextBottomScratch = new Cartesian3();\r\nconst vertexNormalScratch = new Cartesian3();\r\nconst intersectionScratch = new Cartesian3();\r\nconst cartographicScratch0 = new Cartographic();\r\nconst cartographicScratch1 = new Cartographic();\r\nconst cartographicIntersectionScratch = new Cartographic();\r\n/**\r\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\r\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\r\n * Should not be called independent of {@link GroundPolylinePrimitive}.\r\n *\r\n * @param {GroundPolylineGeometry} groundPolylineGeometry\r\n * @private\r\n */\r\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\r\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\r\n  let loop = groundPolylineGeometry.loop;\r\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\r\n  const granularity = groundPolylineGeometry.granularity;\r\n  const arcType = groundPolylineGeometry.arcType;\r\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\r\n    ellipsoid\r\n  );\r\n\r\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\r\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\r\n\r\n  let index;\r\n  let i;\r\n\r\n  const positions = groundPolylineGeometry._positions;\r\n  const positionsLength = positions.length;\r\n\r\n  if (positionsLength === 2) {\r\n    loop = false;\r\n  }\r\n\r\n  // Split positions across the IDL and the Prime Meridian as well.\r\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\r\n  // may get split by the plane of IDL + Prime Meridian.\r\n  let p0;\r\n  let p1;\r\n  let c0;\r\n  let c1;\r\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n  let intersection;\r\n  let intersectionCartographic;\r\n  let intersectionLongitude;\r\n  const splitPositions = [positions[0]];\r\n  for (i = 0; i < positionsLength - 1; i++) {\r\n    p0 = positions[i];\r\n    p1 = positions[i + 1];\r\n    intersection = IntersectionTests.lineSegmentPlane(\r\n      p0,\r\n      p1,\r\n      XZ_PLANE,\r\n      intersectionScratch\r\n    );\r\n    if (\r\n      defined(intersection) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n    ) {\r\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n        splitPositions.push(Cartesian3.clone(intersection));\r\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\r\n          intersection,\r\n          cartographicScratch0\r\n        ).longitude;\r\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n        rhumbLine.setEndPoints(c0, c1);\r\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\r\n          intersectionLongitude,\r\n          cartographicIntersectionScratch\r\n        );\r\n        intersection = ellipsoid.cartographicToCartesian(\r\n          intersectionCartographic,\r\n          intersectionScratch\r\n        );\r\n        if (\r\n          defined(intersection) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n        ) {\r\n          splitPositions.push(Cartesian3.clone(intersection));\r\n        }\r\n      }\r\n    }\r\n    splitPositions.push(p1);\r\n  }\r\n\r\n  if (loop) {\r\n    p0 = positions[positionsLength - 1];\r\n    p1 = positions[0];\r\n    intersection = IntersectionTests.lineSegmentPlane(\r\n      p0,\r\n      p1,\r\n      XZ_PLANE,\r\n      intersectionScratch\r\n    );\r\n    if (\r\n      defined(intersection) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n    ) {\r\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n        splitPositions.push(Cartesian3.clone(intersection));\r\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\r\n          intersection,\r\n          cartographicScratch0\r\n        ).longitude;\r\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n        rhumbLine.setEndPoints(c0, c1);\r\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\r\n          intersectionLongitude,\r\n          cartographicIntersectionScratch\r\n        );\r\n        intersection = ellipsoid.cartographicToCartesian(\r\n          intersectionCartographic,\r\n          intersectionScratch\r\n        );\r\n        if (\r\n          defined(intersection) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n        ) {\r\n          splitPositions.push(Cartesian3.clone(intersection));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  let cartographicsLength = splitPositions.length;\r\n\r\n  let cartographics = new Array(cartographicsLength);\r\n  for (i = 0; i < cartographicsLength; i++) {\r\n    const cartographic = Cartographic.fromCartesian(\r\n      splitPositions[i],\r\n      ellipsoid\r\n    );\r\n    cartographic.height = 0.0;\r\n    cartographics[i] = cartographic;\r\n  }\r\n\r\n  cartographics = arrayRemoveDuplicates(\r\n    cartographics,\r\n    Cartographic.equalsEpsilon\r\n  );\r\n  cartographicsLength = cartographics.length;\r\n\r\n  if (cartographicsLength < 2) {\r\n    return undefined;\r\n  }\r\n\r\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\r\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\r\n  // of information about the wall. Also, this simplifies interpolation.\r\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\r\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\r\n  const cartographicsArray = [];\r\n  const normalsArray = [];\r\n  const bottomPositionsArray = [];\r\n  const topPositionsArray = [];\r\n\r\n  let previousBottom = previousBottomScratch;\r\n  let vertexBottom = vertexBottomScratch;\r\n  let vertexTop = vertexTopScratch;\r\n  let nextBottom = nextBottomScratch;\r\n  let vertexNormal = vertexNormalScratch;\r\n\r\n  // First point - either loop or attach a \"perpendicular\" normal\r\n  const startCartographic = cartographics[0];\r\n  const nextCartographic = cartographics[1];\r\n\r\n  const prestartCartographic = cartographics[cartographicsLength - 1];\r\n  previousBottom = getPosition(\r\n    ellipsoid,\r\n    prestartCartographic,\r\n    minHeight,\r\n    previousBottom\r\n  );\r\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\r\n  vertexBottom = getPosition(\r\n    ellipsoid,\r\n    startCartographic,\r\n    minHeight,\r\n    vertexBottom\r\n  );\r\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\r\n\r\n  if (loop) {\r\n    vertexNormal = computeVertexMiterNormal(\r\n      previousBottom,\r\n      vertexBottom,\r\n      vertexTop,\r\n      nextBottom,\r\n      vertexNormal\r\n    );\r\n  } else {\r\n    vertexNormal = computeRightNormal(\r\n      startCartographic,\r\n      nextCartographic,\r\n      maxHeight,\r\n      ellipsoid,\r\n      vertexNormal\r\n    );\r\n  }\r\n\r\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\r\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\r\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\r\n  cartographicsArray.push(startCartographic.latitude);\r\n  cartographicsArray.push(startCartographic.longitude);\r\n\r\n  interpolateSegment(\r\n    startCartographic,\r\n    nextCartographic,\r\n    minHeight,\r\n    maxHeight,\r\n    granularity,\r\n    arcType,\r\n    ellipsoid,\r\n    normalsArray,\r\n    bottomPositionsArray,\r\n    topPositionsArray,\r\n    cartographicsArray\r\n  );\r\n\r\n  // All inbetween points\r\n  for (i = 1; i < cartographicsLength - 1; ++i) {\r\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\r\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\r\n    const vertexCartographic = cartographics[i];\r\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\r\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\r\n\r\n    computeVertexMiterNormal(\r\n      previousBottom,\r\n      vertexBottom,\r\n      vertexTop,\r\n      nextBottom,\r\n      vertexNormal\r\n    );\r\n\r\n    index = normalsArray.length;\r\n    Cartesian3.pack(vertexNormal, normalsArray, index);\r\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n    cartographicsArray.push(vertexCartographic.latitude);\r\n    cartographicsArray.push(vertexCartographic.longitude);\r\n\r\n    interpolateSegment(\r\n      cartographics[i],\r\n      cartographics[i + 1],\r\n      minHeight,\r\n      maxHeight,\r\n      granularity,\r\n      arcType,\r\n      ellipsoid,\r\n      normalsArray,\r\n      bottomPositionsArray,\r\n      topPositionsArray,\r\n      cartographicsArray\r\n    );\r\n  }\r\n\r\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\r\n  const endCartographic = cartographics[cartographicsLength - 1];\r\n  const preEndCartographic = cartographics[cartographicsLength - 2];\r\n\r\n  vertexBottom = getPosition(\r\n    ellipsoid,\r\n    endCartographic,\r\n    minHeight,\r\n    vertexBottom\r\n  );\r\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\r\n\r\n  if (loop) {\r\n    const postEndCartographic = cartographics[0];\r\n    previousBottom = getPosition(\r\n      ellipsoid,\r\n      preEndCartographic,\r\n      minHeight,\r\n      previousBottom\r\n    );\r\n    nextBottom = getPosition(\r\n      ellipsoid,\r\n      postEndCartographic,\r\n      minHeight,\r\n      nextBottom\r\n    );\r\n\r\n    vertexNormal = computeVertexMiterNormal(\r\n      previousBottom,\r\n      vertexBottom,\r\n      vertexTop,\r\n      nextBottom,\r\n      vertexNormal\r\n    );\r\n  } else {\r\n    vertexNormal = computeRightNormal(\r\n      preEndCartographic,\r\n      endCartographic,\r\n      maxHeight,\r\n      ellipsoid,\r\n      vertexNormal\r\n    );\r\n  }\r\n\r\n  index = normalsArray.length;\r\n  Cartesian3.pack(vertexNormal, normalsArray, index);\r\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n  cartographicsArray.push(endCartographic.latitude);\r\n  cartographicsArray.push(endCartographic.longitude);\r\n\r\n  if (loop) {\r\n    interpolateSegment(\r\n      endCartographic,\r\n      startCartographic,\r\n      minHeight,\r\n      maxHeight,\r\n      granularity,\r\n      arcType,\r\n      ellipsoid,\r\n      normalsArray,\r\n      bottomPositionsArray,\r\n      topPositionsArray,\r\n      cartographicsArray\r\n    );\r\n    index = normalsArray.length;\r\n    for (i = 0; i < 3; ++i) {\r\n      normalsArray[index + i] = normalsArray[i];\r\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\r\n      topPositionsArray[index + i] = topPositionsArray[i];\r\n    }\r\n    cartographicsArray.push(startCartographic.latitude);\r\n    cartographicsArray.push(startCartographic.longitude);\r\n  }\r\n\r\n  return generateGeometryAttributes(\r\n    loop,\r\n    projection,\r\n    bottomPositionsArray,\r\n    topPositionsArray,\r\n    normalsArray,\r\n    cartographicsArray,\r\n    compute2dAttributes\r\n  );\r\n};\r\n\r\n// If the end normal angle is too steep compared to the direction of the line segment,\r\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\r\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\r\nconst lineDirectionScratch = new Cartesian3();\r\nconst matrix3Scratch = new Matrix3();\r\nconst quaternionScratch = new Quaternion();\r\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\r\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\r\n\r\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\r\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\r\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\r\n    const angle =\r\n      dot < MITER_BREAK_LARGE\r\n        ? CesiumMath.PI_OVER_TWO\r\n        : -CesiumMath.PI_OVER_TWO;\r\n    const quaternion = Quaternion.fromAxisAngle(\r\n      vertexUp,\r\n      angle,\r\n      quaternionScratch\r\n    );\r\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\r\n    Matrix3.multiplyByVector(\r\n      rotationMatrix,\r\n      endGeometryNormal,\r\n      endGeometryNormal\r\n    );\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst endPosCartographicScratch = new Cartographic();\r\nconst normalStartpointScratch = new Cartesian3();\r\nconst normalEndpointScratch = new Cartesian3();\r\nfunction projectNormal(\r\n  projection,\r\n  cartographic,\r\n  normal,\r\n  projectedPosition,\r\n  result\r\n) {\r\n  const position = Cartographic.toCartesian(\r\n    cartographic,\r\n    projection._ellipsoid,\r\n    normalStartpointScratch\r\n  );\r\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\r\n  let flipNormal = false;\r\n\r\n  const ellipsoid = projection._ellipsoid;\r\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(\r\n    normalEndpoint,\r\n    endPosCartographicScratch\r\n  );\r\n  // If normal crosses the IDL, go the other way and flip the result.\r\n  // In practice this almost never happens because the cartographic start\r\n  // and end points of each segment are \"nudged\" to be on the same side\r\n  // of the IDL and slightly away from the IDL.\r\n  if (\r\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\r\n    CesiumMath.PI_OVER_TWO\r\n  ) {\r\n    flipNormal = true;\r\n    normalEndpoint = Cartesian3.subtract(\r\n      position,\r\n      normal,\r\n      normalEndpointScratch\r\n    );\r\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\r\n      normalEndpoint,\r\n      endPosCartographicScratch\r\n    );\r\n  }\r\n\r\n  normalEndpointCartographic.height = 0.0;\r\n  const normalEndpointProjected = projection.project(\r\n    normalEndpointCartographic,\r\n    result\r\n  );\r\n  result = Cartesian3.subtract(\r\n    normalEndpointProjected,\r\n    projectedPosition,\r\n    result\r\n  );\r\n  result.z = 0.0;\r\n  result = Cartesian3.normalize(result, result);\r\n  if (flipNormal) {\r\n    Cartesian3.negate(result, result);\r\n  }\r\n  return result;\r\n}\r\n\r\nconst adjustHeightNormalScratch = new Cartesian3();\r\nconst adjustHeightOffsetScratch = new Cartesian3();\r\nfunction adjustHeights(\r\n  bottom,\r\n  top,\r\n  minHeight,\r\n  maxHeight,\r\n  adjustHeightBottom,\r\n  adjustHeightTop\r\n) {\r\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\r\n  const adjustHeightNormal = Cartesian3.subtract(\r\n    top,\r\n    bottom,\r\n    adjustHeightNormalScratch\r\n  );\r\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\r\n\r\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\r\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(\r\n    adjustHeightNormal,\r\n    distanceForBottom,\r\n    adjustHeightOffsetScratch\r\n  );\r\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\r\n\r\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\r\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\r\n    adjustHeightNormal,\r\n    distanceForTop,\r\n    adjustHeightOffsetScratch\r\n  );\r\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\r\n}\r\n\r\nconst nudgeDirectionScratch = new Cartesian3();\r\nfunction nudgeXZ(start, end) {\r\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\r\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\r\n  let offset = nudgeDirectionScratch;\r\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\r\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n    offset = direction(end, start, offset);\r\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n    Cartesian3.add(start, offset, start);\r\n  } else if (\r\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\r\n  ) {\r\n    offset = direction(start, end, offset);\r\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n    Cartesian3.add(end, offset, end);\r\n  }\r\n}\r\n\r\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\r\n// Nudge amounts are tiny, basically just an IDL flip.\r\n// Only used for 2D/CV.\r\nfunction nudgeCartographic(start, end) {\r\n  const absStartLon = Math.abs(start.longitude);\r\n  const absEndLon = Math.abs(end.longitude);\r\n  if (\r\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\r\n  ) {\r\n    const endSign = CesiumMath.sign(end.longitude);\r\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\r\n    return 1;\r\n  } else if (\r\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\r\n  ) {\r\n    const startSign = CesiumMath.sign(start.longitude);\r\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\r\n    return 2;\r\n  }\r\n  return 0;\r\n}\r\n\r\nconst startCartographicScratch = new Cartographic();\r\nconst endCartographicScratch = new Cartographic();\r\n\r\nconst segmentStartTopScratch = new Cartesian3();\r\nconst segmentEndTopScratch = new Cartesian3();\r\nconst segmentStartBottomScratch = new Cartesian3();\r\nconst segmentEndBottomScratch = new Cartesian3();\r\nconst segmentStartNormalScratch = new Cartesian3();\r\nconst segmentEndNormalScratch = new Cartesian3();\r\n\r\nconst getHeightCartographics = [\r\n  startCartographicScratch,\r\n  endCartographicScratch,\r\n];\r\nconst getHeightRectangleScratch = new Rectangle();\r\n\r\nconst adjustHeightStartTopScratch = new Cartesian3();\r\nconst adjustHeightEndTopScratch = new Cartesian3();\r\nconst adjustHeightStartBottomScratch = new Cartesian3();\r\nconst adjustHeightEndBottomScratch = new Cartesian3();\r\n\r\nconst segmentStart2DScratch = new Cartesian3();\r\nconst segmentEnd2DScratch = new Cartesian3();\r\nconst segmentStartNormal2DScratch = new Cartesian3();\r\nconst segmentEndNormal2DScratch = new Cartesian3();\r\n\r\nconst offsetScratch = new Cartesian3();\r\nconst startUpScratch = new Cartesian3();\r\nconst endUpScratch = new Cartesian3();\r\nconst rightScratch = new Cartesian3();\r\nconst startPlaneNormalScratch = new Cartesian3();\r\nconst endPlaneNormalScratch = new Cartesian3();\r\nconst encodeScratch = new EncodedCartesian3();\r\n\r\nconst encodeScratch2D = new EncodedCartesian3();\r\nconst forwardOffset2DScratch = new Cartesian3();\r\nconst right2DScratch = new Cartesian3();\r\n\r\nconst normalNudgeScratch = new Cartesian3();\r\n\r\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\r\n\r\n// Winding order is reversed so each segment's volume is inside-out\r\nconst REFERENCE_INDICES = [\r\n  0,\r\n  2,\r\n  1,\r\n  0,\r\n  3,\r\n  2, // right\r\n  0,\r\n  7,\r\n  3,\r\n  0,\r\n  4,\r\n  7, // start\r\n  0,\r\n  5,\r\n  4,\r\n  0,\r\n  1,\r\n  5, // bottom\r\n  5,\r\n  7,\r\n  4,\r\n  5,\r\n  6,\r\n  7, // left\r\n  5,\r\n  2,\r\n  6,\r\n  5,\r\n  1,\r\n  2, // end\r\n  3,\r\n  6,\r\n  2,\r\n  3,\r\n  7,\r\n  6, // top\r\n];\r\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\n// Decompose the \"wall\" into a series of shadow volumes.\r\n// Each shadow volume's vertices encode a description of the line it contains,\r\n// including mitering planes at the end points, a plane along the line itself,\r\n// and attributes for computing length-wise texture coordinates.\r\nfunction generateGeometryAttributes(\r\n  loop,\r\n  projection,\r\n  bottomPositionsArray,\r\n  topPositionsArray,\r\n  normalsArray,\r\n  cartographicsArray,\r\n  compute2dAttributes\r\n) {\r\n  let i;\r\n  let index;\r\n  const ellipsoid = projection._ellipsoid;\r\n\r\n  // Each segment will have 8 vertices\r\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\r\n  const vertexCount = segmentCount * 8;\r\n  const arraySizeVec4 = vertexCount * 4;\r\n  const indexCount = segmentCount * 36;\r\n\r\n  const indices =\r\n    vertexCount > 65535\r\n      ? new Uint32Array(indexCount)\r\n      : new Uint16Array(indexCount);\r\n  const positionsArray = new Float64Array(vertexCount * 3);\r\n\r\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\r\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\r\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\r\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(\r\n    arraySizeVec4\r\n  );\r\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\r\n    arraySizeVec4\r\n  );\r\n\r\n  let startHiLo2D;\r\n  let offsetAndRight2D;\r\n  let startEndNormals2D;\r\n  let texcoordNormalization2D;\r\n\r\n  if (compute2dAttributes) {\r\n    startHiLo2D = new Float32Array(arraySizeVec4);\r\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\r\n    startEndNormals2D = new Float32Array(arraySizeVec4);\r\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\r\n  }\r\n\r\n  /*** Compute total lengths for texture coordinate normalization ***/\r\n  // 2D\r\n  const cartographicsLength = cartographicsArray.length / 2;\r\n  let length2D = 0.0;\r\n\r\n  const startCartographic = startCartographicScratch;\r\n  startCartographic.height = 0.0;\r\n  const endCartographic = endCartographicScratch;\r\n  endCartographic.height = 0.0;\r\n\r\n  let segmentStartCartesian = segmentStartTopScratch;\r\n  let segmentEndCartesian = segmentEndTopScratch;\r\n\r\n  if (compute2dAttributes) {\r\n    index = 0;\r\n    for (i = 1; i < cartographicsLength; i++) {\r\n      // Don't clone anything from previous segment b/c possible IDL touch\r\n      startCartographic.latitude = cartographicsArray[index];\r\n      startCartographic.longitude = cartographicsArray[index + 1];\r\n      endCartographic.latitude = cartographicsArray[index + 2];\r\n      endCartographic.longitude = cartographicsArray[index + 3];\r\n\r\n      segmentStartCartesian = projection.project(\r\n        startCartographic,\r\n        segmentStartCartesian\r\n      );\r\n      segmentEndCartesian = projection.project(\r\n        endCartographic,\r\n        segmentEndCartesian\r\n      );\r\n      length2D += Cartesian3.distance(\r\n        segmentStartCartesian,\r\n        segmentEndCartesian\r\n      );\r\n      index += 2;\r\n    }\r\n  }\r\n\r\n  // 3D\r\n  const positionsLength = topPositionsArray.length / 3;\r\n  segmentEndCartesian = Cartesian3.unpack(\r\n    topPositionsArray,\r\n    0,\r\n    segmentEndCartesian\r\n  );\r\n  let length3D = 0.0;\r\n\r\n  index = 3;\r\n  for (i = 1; i < positionsLength; i++) {\r\n    segmentStartCartesian = Cartesian3.clone(\r\n      segmentEndCartesian,\r\n      segmentStartCartesian\r\n    );\r\n    segmentEndCartesian = Cartesian3.unpack(\r\n      topPositionsArray,\r\n      index,\r\n      segmentEndCartesian\r\n    );\r\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n    index += 3;\r\n  }\r\n\r\n  /*** Generate segments ***/\r\n  let j;\r\n  index = 3;\r\n  let cartographicsIndex = 0;\r\n  let vec2sWriteIndex = 0;\r\n  let vec3sWriteIndex = 0;\r\n  let vec4sWriteIndex = 0;\r\n  let miterBroken = false;\r\n\r\n  let endBottom = Cartesian3.unpack(\r\n    bottomPositionsArray,\r\n    0,\r\n    segmentEndBottomScratch\r\n  );\r\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\r\n  let endGeometryNormal = Cartesian3.unpack(\r\n    normalsArray,\r\n    0,\r\n    segmentEndNormalScratch\r\n  );\r\n\r\n  if (loop) {\r\n    const preEndBottom = Cartesian3.unpack(\r\n      bottomPositionsArray,\r\n      bottomPositionsArray.length - 6,\r\n      segmentStartBottomScratch\r\n    );\r\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\r\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\r\n      endGeometryNormal = Cartesian3.negate(\r\n        endGeometryNormal,\r\n        endGeometryNormal\r\n      );\r\n    }\r\n  }\r\n\r\n  let lengthSoFar3D = 0.0;\r\n  let lengthSoFar2D = 0.0;\r\n\r\n  // For translating bounding volume\r\n  let sumHeights = 0.0;\r\n\r\n  for (i = 0; i < segmentCount; i++) {\r\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\r\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\r\n    let startGeometryNormal = Cartesian3.clone(\r\n      endGeometryNormal,\r\n      segmentStartNormalScratch\r\n    );\r\n\r\n    if (miterBroken) {\r\n      startGeometryNormal = Cartesian3.negate(\r\n        startGeometryNormal,\r\n        startGeometryNormal\r\n      );\r\n    }\r\n\r\n    endBottom = Cartesian3.unpack(\r\n      bottomPositionsArray,\r\n      index,\r\n      segmentEndBottomScratch\r\n    );\r\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\r\n    endGeometryNormal = Cartesian3.unpack(\r\n      normalsArray,\r\n      index,\r\n      segmentEndNormalScratch\r\n    );\r\n\r\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\r\n\r\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\r\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\r\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\r\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\r\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\r\n    let start2D;\r\n    let end2D;\r\n    let startGeometryNormal2D;\r\n    let endGeometryNormal2D;\r\n\r\n    if (compute2dAttributes) {\r\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\r\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\r\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\r\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\r\n      direction2D.y = Math.abs(direction2D.y);\r\n\r\n      startGeometryNormal2D = segmentStartNormal2DScratch;\r\n      endGeometryNormal2D = segmentEndNormal2DScratch;\r\n      if (\r\n        nudgeResult === 0 ||\r\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\r\n      ) {\r\n        // No nudge - project the original normal\r\n        // Or, if the line's angle relative to the IDL is very acute,\r\n        // in which case snapping will produce oddly shaped volumes.\r\n        startGeometryNormal2D = projectNormal(\r\n          projection,\r\n          startCartographic,\r\n          startGeometryNormal,\r\n          start2D,\r\n          segmentStartNormal2DScratch\r\n        );\r\n        endGeometryNormal2D = projectNormal(\r\n          projection,\r\n          endCartographic,\r\n          endGeometryNormal,\r\n          end2D,\r\n          segmentEndNormal2DScratch\r\n        );\r\n      } else if (nudgeResult === 1) {\r\n        // Start is close to IDL - snap start normal to align with IDL\r\n        endGeometryNormal2D = projectNormal(\r\n          projection,\r\n          endCartographic,\r\n          endGeometryNormal,\r\n          end2D,\r\n          segmentEndNormal2DScratch\r\n        );\r\n        startGeometryNormal2D.x = 0.0;\r\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\r\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\r\n        startGeometryNormal2D.y = CesiumMath.sign(\r\n          startCartographic.longitude - Math.abs(endCartographic.longitude)\r\n        );\r\n        startGeometryNormal2D.z = 0.0;\r\n      } else {\r\n        // End is close to IDL - snap end normal to align with IDL\r\n        startGeometryNormal2D = projectNormal(\r\n          projection,\r\n          startCartographic,\r\n          startGeometryNormal,\r\n          start2D,\r\n          segmentStartNormal2DScratch\r\n        );\r\n        endGeometryNormal2D.x = 0.0;\r\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\r\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\r\n        endGeometryNormal2D.y = CesiumMath.sign(\r\n          startCartographic.longitude - endCartographic.longitude\r\n        );\r\n        endGeometryNormal2D.z = 0.0;\r\n      }\r\n    }\r\n\r\n    /****************************************\r\n     * Geometry descriptors of a \"line on terrain,\"\r\n     * as opposed to the \"shadow volume used to draw\r\n     * the line on terrain\":\r\n     * - position of start + offset to end\r\n     * - start, end, and right-facing planes\r\n     * - encoded texture coordinate offsets\r\n     ****************************************/\r\n\r\n    /* 3D */\r\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\r\n\r\n    const encodedStart = EncodedCartesian3.fromCartesian(\r\n      startBottom,\r\n      encodeScratch\r\n    );\r\n    const forwardOffset = Cartesian3.subtract(\r\n      endBottom,\r\n      startBottom,\r\n      offsetScratch\r\n    );\r\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\r\n\r\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\r\n    startUp = Cartesian3.normalize(startUp, startUp);\r\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\r\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\r\n\r\n    let startPlaneNormal = Cartesian3.cross(\r\n      startUp,\r\n      startGeometryNormal,\r\n      startPlaneNormalScratch\r\n    );\r\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\r\n\r\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\r\n    endUp = Cartesian3.normalize(endUp, endUp);\r\n    let endPlaneNormal = Cartesian3.cross(\r\n      endGeometryNormal,\r\n      endUp,\r\n      endPlaneNormalScratch\r\n    );\r\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\r\n\r\n    const texcoordNormalization3DX = segmentLength3D / length3D;\r\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\r\n\r\n    /* 2D */\r\n    let segmentLength2D = 0.0;\r\n    let encodedStart2D;\r\n    let forwardOffset2D;\r\n    let right2D;\r\n    let texcoordNormalization2DX = 0.0;\r\n    let texcoordNormalization2DY = 0.0;\r\n    if (compute2dAttributes) {\r\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\r\n\r\n      encodedStart2D = EncodedCartesian3.fromCartesian(\r\n        start2D,\r\n        encodeScratch2D\r\n      );\r\n      forwardOffset2D = Cartesian3.subtract(\r\n        end2D,\r\n        start2D,\r\n        forwardOffset2DScratch\r\n      );\r\n\r\n      // Right direction is just forward direction rotated by -90 degrees around Z\r\n      // Similarly with plane normals\r\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\r\n      const swap = right2D.x;\r\n      right2D.x = right2D.y;\r\n      right2D.y = -swap;\r\n\r\n      texcoordNormalization2DX = segmentLength2D / length2D;\r\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\r\n    }\r\n    /** Pack **/\r\n    for (j = 0; j < 8; j++) {\r\n      const vec4Index = vec4sWriteIndex + j * 4;\r\n      const vec2Index = vec2sWriteIndex + j * 2;\r\n      const wIndex = vec4Index + 3;\r\n\r\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\r\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\r\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\r\n      const topBottomSide =\r\n        j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\r\n\r\n      // 3D\r\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\r\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\r\n\r\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\r\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\r\n\r\n      Cartesian3.pack(\r\n        startPlaneNormal,\r\n        startNormalAndForwardOffsetZ,\r\n        vec4Index\r\n      );\r\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\r\n\r\n      Cartesian3.pack(\r\n        endPlaneNormal,\r\n        endNormalAndTextureCoordinateNormalizationX,\r\n        vec4Index\r\n      );\r\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\r\n        texcoordNormalization3DX * rightPlaneSide;\r\n\r\n      Cartesian3.pack(\r\n        rightNormal,\r\n        rightNormalAndTextureCoordinateNormalizationY,\r\n        vec4Index\r\n      );\r\n\r\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\r\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n        texcoordNormalization = 9.0; // some value greater than 1.0\r\n      }\r\n      rightNormalAndTextureCoordinateNormalizationY[\r\n        wIndex\r\n      ] = texcoordNormalization;\r\n\r\n      // 2D\r\n      if (compute2dAttributes) {\r\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\r\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\r\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\r\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\r\n\r\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\r\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\r\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\r\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\r\n\r\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\r\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\r\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\r\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\r\n\r\n        texcoordNormalization2D[vec2Index] =\r\n          texcoordNormalization2DX * rightPlaneSide;\r\n\r\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\r\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n          texcoordNormalization = 9.0; // some value greater than 1.0\r\n        }\r\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\r\n      }\r\n    }\r\n\r\n    // Adjust height of volume in 3D\r\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\r\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\r\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\r\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\r\n\r\n    const getHeightsRectangle = Rectangle.fromCartographicArray(\r\n      getHeightCartographics,\r\n      getHeightRectangleScratch\r\n    );\r\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\r\n      getHeightsRectangle,\r\n      ellipsoid\r\n    );\r\n    const minHeight = minMaxHeights.minimumTerrainHeight;\r\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\r\n\r\n    sumHeights += minHeight;\r\n    sumHeights += maxHeight;\r\n\r\n    adjustHeights(\r\n      startBottom,\r\n      startTop,\r\n      minHeight,\r\n      maxHeight,\r\n      adjustHeightStartBottom,\r\n      adjustHeightStartTop\r\n    );\r\n    adjustHeights(\r\n      endBottom,\r\n      endTop,\r\n      minHeight,\r\n      maxHeight,\r\n      adjustHeightEndBottom,\r\n      adjustHeightEndTop\r\n    );\r\n\r\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\r\n    let normalNudge = Cartesian3.multiplyByScalar(\r\n      rightNormal,\r\n      CesiumMath.EPSILON5,\r\n      normalNudgeScratch\r\n    );\r\n    Cartesian3.add(\r\n      adjustHeightStartBottom,\r\n      normalNudge,\r\n      adjustHeightStartBottom\r\n    );\r\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\r\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\r\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\r\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\r\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\r\n\r\n    normalNudge = Cartesian3.multiplyByScalar(\r\n      rightNormal,\r\n      -2.0 * CesiumMath.EPSILON5,\r\n      normalNudgeScratch\r\n    );\r\n    Cartesian3.add(\r\n      adjustHeightStartBottom,\r\n      normalNudge,\r\n      adjustHeightStartBottom\r\n    );\r\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n    Cartesian3.pack(\r\n      adjustHeightStartBottom,\r\n      positionsArray,\r\n      vec3sWriteIndex + 12\r\n    );\r\n    Cartesian3.pack(\r\n      adjustHeightEndBottom,\r\n      positionsArray,\r\n      vec3sWriteIndex + 15\r\n    );\r\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\r\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\r\n\r\n    cartographicsIndex += 2;\r\n    index += 3;\r\n\r\n    vec2sWriteIndex += 16;\r\n    vec3sWriteIndex += 24;\r\n    vec4sWriteIndex += 32;\r\n\r\n    lengthSoFar3D += segmentLength3D;\r\n    lengthSoFar2D += segmentLength2D;\r\n  }\r\n\r\n  index = 0;\r\n  let indexOffset = 0;\r\n  for (i = 0; i < segmentCount; i++) {\r\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\r\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\r\n    }\r\n    indexOffset += 8;\r\n    index += REFERENCE_INDICES_LENGTH;\r\n  }\r\n\r\n  const boundingSpheres = scratchBoundingSpheres;\r\n  BoundingSphere.fromVertices(\r\n    bottomPositionsArray,\r\n    Cartesian3.ZERO,\r\n    3,\r\n    boundingSpheres[0]\r\n  );\r\n  BoundingSphere.fromVertices(\r\n    topPositionsArray,\r\n    Cartesian3.ZERO,\r\n    3,\r\n    boundingSpheres[1]\r\n  );\r\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\r\n\r\n  // Adjust bounding sphere height and radius to cover more of the volume\r\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\r\n\r\n  const attributes = {\r\n    position: new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.DOUBLE,\r\n      componentsPerAttribute: 3,\r\n      normalize: false,\r\n      values: positionsArray,\r\n    }),\r\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\r\n      startHiAndForwardOffsetX\r\n    ),\r\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\r\n      startLoAndForwardOffsetY\r\n    ),\r\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\r\n      startNormalAndForwardOffsetZ\r\n    ),\r\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\r\n      endNormalAndTextureCoordinateNormalizationX\r\n    ),\r\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\r\n      rightNormalAndTextureCoordinateNormalizationY\r\n    ),\r\n  };\r\n\r\n  if (compute2dAttributes) {\r\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\r\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\r\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\r\n    attributes.texcoordNormalization2D = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      normalize: false,\r\n      values: texcoordNormalization2D,\r\n    });\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    boundingSphere: boundingSphere,\r\n  });\r\n}\r\n\r\nfunction getVec4GeometryAttribute(typedArray) {\r\n  return new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: 4,\r\n    normalize: false,\r\n    values: typedArray,\r\n  });\r\n}\r\n\r\n/**\r\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\r\n * Exposed for testing.\r\n *\r\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\r\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\r\n *   Used to check if the normal crosses the IDL during projection.\r\n * @param {Cartesian3} normal The normal in 3D.\r\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\r\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\r\n * @private\r\n */\r\nGroundPolylineGeometry._projectNormal = projectNormal;\r\nexport default GroundPolylineGeometry;\r\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\r\n\r\nfunction createGroundPolylineGeometry(groundPolylineGeometry, offset) {\r\n  return ApproximateTerrainHeights.initialize().then(function () {\r\n    if (defined(offset)) {\r\n      groundPolylineGeometry = GroundPolylineGeometry.unpack(\r\n        groundPolylineGeometry,\r\n        offset\r\n      );\r\n    }\r\n    return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\r\n  });\r\n}\r\nexport default createGroundPolylineGeometry;\r\n"],"names":["GeographicTilingScheme","options","defaultValue","EMPTY_OBJECT","this","_ellipsoid","ellipsoid","Ellipsoid","WGS84","_rectangle","rectangle","Rectangle","MAX_VALUE","_projection","GeographicProjection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","Object","defineProperties","prototype","get","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","Check","defined","west","CesiumMath","toDegrees","south","east","north","tileXYToNativeRectangle","x","y","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","width","yTileHeight","height","positionToTileXY","position","contains","longitude","TWO_PI","xTileCoordinate","yTileCoordinate","latitude","Cartesian2","scratchDiagonalCartesianNE","Cartesian3","scratchDiagonalCartesianSW","scratchDiagonalCartographic","Cartographic","scratchCenterCartesian","scratchSurfaceCartesian","scratchBoundingSphere","BoundingSphere","tilingScheme","scratchCorners","scratchTileXY","ApproximateTerrainHeights","getTileXYLevel","fromRadians","lastLevelX","lastLevelY","currentX","currentY","maxLevel","_terrainHeightsMaxLevel","i","failed","j","corner","initialize","initPromise","_initPromise","Resource","fetchJson","buildModuleUrl","then","json","_terrainHeights","getMinimumMaximumHeights","DeveloperError","xyLevel","minTerrainHeight","_defaultMinTerrainHeight","maxTerrainHeight","_defaultMaxTerrainHeight","key","heights","cartographicToCartesian","northeast","southwest","midpoint","surfacePosition","scaleToGeodeticSurface","distance","Math","min","max","minimumTerrainHeight","maximumTerrainHeight","getBoundingSphere","fromRectangle3D","union","undefined","initialized","PROJECTIONS","WebMercatorProjection","PROJECTION_COUNT","length","MITER_BREAK_SMALL","cos","toRadians","MITER_BREAK_LARGE","WALL_INITIAL_MIN_HEIGHT","WALL_INITIAL_MAX_HEIGHT","GroundPolylineGeometry","positions","arcType","ArcType","GEODESIC","RHUMB","_positions","granularity","loop","_projectionIndex","_workerName","_scene3DOnly","packedLength","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","end","maxHeight","startBottom","getPosition","startTop","endBottom","up","direction","forward","cross","normalize","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","EllipsoidGeodesic","EllipsoidRhumbLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","pack","push","heightlessCartographicScratch","cartographic","clone","toCartesian","target","origin","subtract","tangentDirection","value","array","startingIndex","typeOf","object","index","positionsLength","cartesian","unpack","Array","scene3DOnly","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","equalsEpsilon","dot","EPSILON5","add","negate","XZ_PLANE","Plane","fromPointNormal","ZERO","UNIT_Y","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","compute2dAttributes","p0","p1","c0","c1","rhumbLine","intersection","intersectionCartographic","intersectionLongitude","splitPositions","IntersectionTests","lineSegmentPlane","EPSILON7","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicsLength","cartographics","fromCartesian","arrayRemoveDuplicates","vertexNormal","startCartographic","nextCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","segmentCount","vertexCount","arraySizeVec4","indexCount","indices","Uint32Array","Uint16Array","positionsArray","Float64Array","startHiAndForwardOffsetX","Float32Array","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","length2D","startCartographicScratch","endCartographicScratch","segmentStartCartesian","segmentStartTopScratch","segmentEndCartesian","segmentEndTopScratch","project","length3D","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","segmentEndBottomScratch","endTop","endGeometryNormal","segmentEndNormalScratch","breakMiter","segmentStartBottomScratch","lengthSoFar3D","lengthSoFar2D","sumHeights","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","startGeometryNormal","segmentStartNormalScratch","nudgeResult","nudgeCartographic","segmentStart2DScratch","segmentEnd2DScratch","direction2D","forwardOffset2DScratch","abs","segmentStartNormal2DScratch","segmentEndNormal2DScratch","projectNormal","sign","z","segmentLength3D","encodedStart","EncodedCartesian3","encodeScratch","forwardOffset","offsetScratch","rightScratch","startUp","startUpScratch","rightNormal","startPlaneNormal","startPlaneNormalScratch","endUp","endUpScratch","endPlaneNormal","endPlaneNormalScratch","texcoordNormalization3DX","texcoordNormalization3DY","encodedStart2D","forwardOffset2D","right2D","segmentLength2D","texcoordNormalization2DX","texcoordNormalization2DY","encodeScratch2D","right2DScratch","swap","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightStartBottomScratch","adjustHeightEndBottom","adjustHeightEndBottomScratch","adjustHeightStartTop","adjustHeightStartTopScratch","adjustHeightEndTop","adjustHeightEndTopScratch","getHeightsRectangle","fromCartographicArray","getHeightCartographics","getHeightRectangleScratch","minMaxHeights","adjustHeights","normalNudge","multiplyByScalar","normalNudgeScratch","nudgeXZ","indexOffset","REFERENCE_INDICES_LENGTH","REFERENCE_INDICES","boundingSpheres","scratchBoundingSpheres","fromVertices","boundingSphere","fromBoundingSpheres","radius","attributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","getVec4GeometryAttribute","FLOAT","Geometry","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","Matrix3","quaternionScratch","Quaternion","lineDirection","vertexUp","angle","PI_OVER_TWO","quaternion","fromAxisAngle","rotationMatrix","fromQuaternion","multiplyByVector","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","normal","projectedPosition","normalEndpoint","flipNormal","normalEndpointCartographic","normalEndpointProjected","adjustHeightNormalScratch","adjustHeightOffsetScratch","bottom","top","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","distanceForTop","nudgeDirectionScratch","startToXZdistance","getPointDistance","endToXZdistance","offset","EPSILON2","absStartLon","absEndLon","PI","EPSILON11","endSign","startSign","typedArray","_projectNormal"],"mappings":"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"}