/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-ac2201bb","./Matrix2-5bde29de","./ArcType-5c683766","./BoundingRectangle-fd9a5062","./Transforms-3f580a0c","./RuntimeError-d45af186","./ComponentDatatype-164c57e1","./EllipsoidGeodesic-dedaf218","./EllipsoidTangentPlane-fa2bc0dc","./GeometryAttribute-f83e6129","./GeometryInstance-2bd4ec32","./GeometryOffsetAttribute-a17b96d9","./GeometryPipeline-690feb65","./IndexDatatype-4e1ec1a1","./PolygonGeometryLibrary-348a165a","./PolygonPipeline-71d5516a","./VertexFormat-4a6cdfad","./_commonjsHelpers-3aae1032-ac53d93e","./combine-0dce9b0f","./WebGLConstants-e12cdc8a","./AxisAlignedBoundingBox-b2f2975e","./IntersectionTests-0d91a773","./Plane-3ad20be7","./AttributeCompression-1cfcbb75","./EncodedCartesian3-83872b10","./arrayRemoveDuplicates-68f14b2f","./EllipsoidRhumbLine-bfb4fa95","./GeometryAttributes-d060f8b5"],(function(e,t,o,r,i,n,a,s,l,c,u,p,d,y,g,m,h,f,b,_,C,P,x,T,w,A,I,E){"use strict";const v=new t.Cartographic,G=new t.Cartographic;function O(e,t,o,r){const i=r.cartesianToCartographic(e,v).height,n=r.cartesianToCartographic(t,G);n.height=i,r.cartographicToCartesian(n,t);const a=r.cartesianToCartographic(o,G);a.height=i-100,r.cartographicToCartesian(a,o)}const H=new r.BoundingRectangle,D=new t.Cartesian3,V=new t.Cartesian3,L=new t.Cartesian3,N=new t.Cartesian3,F=new t.Cartesian3,R=new t.Cartesian3;let M=new t.Cartesian3,k=new t.Cartesian3,S=new t.Cartesian3;const B=new t.Cartesian2,z=new t.Cartesian2,U=new t.Cartesian3,W=new i.Quaternion,Y=new t.Matrix3,j=new t.Matrix3;function Q(o){const r=o.vertexFormat,n=o.geometry,s=o.shadowVolume,l=n.attributes.position.values,u=e.defined(n.attributes.st)?n.attributes.st.values:void 0;let d=l.length;const y=o.wall,g=o.top||y,m=o.bottom||y;if(r.st||r.normal||r.tangent||r.bitangent||s){const p=o.boundingRectangle,h=o.tangentPlane,f=o.ellipsoid,b=o.stRotation,_=o.perPositionHeight,C=B;C.x=p.x,C.y=p.y;const P=r.st?new Float32Array(d/3*2):void 0;let x;r.normal&&(x=_&&g&&!y?n.attributes.normal.values:new Float32Array(d));const T=r.tangent?new Float32Array(d):void 0,w=r.bitangent?new Float32Array(d):void 0,A=s?new Float32Array(d):void 0;let I=0,E=0,v=V,G=L,H=N,Q=!0,q=Y,K=j;if(0!==b){let e=i.Quaternion.fromAxisAngle(h._plane.normal,b,W);q=t.Matrix3.fromQuaternion(e,q),e=i.Quaternion.fromAxisAngle(h._plane.normal,-b,W),K=t.Matrix3.fromQuaternion(e,K)}else q=t.Matrix3.clone(t.Matrix3.IDENTITY,q),K=t.Matrix3.clone(t.Matrix3.IDENTITY,K);let Z=0,J=0;g&&m&&(Z=d/2,J=d/3,d/=2);for(let i=0;i<d;i+=3){const n=t.Cartesian3.fromArray(l,i,U);if(r.st&&!e.defined(u)){let e=t.Matrix3.multiplyByVector(q,n,D);e=f.scaleToGeodeticSurface(e,e);const o=h.projectPointOntoPlane(e,z);t.Cartesian2.subtract(o,C,o);const r=a.CesiumMath.clamp(o.x/p.width,0,1),i=a.CesiumMath.clamp(o.y/p.height,0,1);m&&(P[I+J]=r,P[I+1+J]=i),g&&(P[I]=r,P[I+1]=i),I+=2}if(r.normal||r.tangent||r.bitangent||s){const e=E+1,c=E+2;if(y){if(i+3<d){const e=t.Cartesian3.fromArray(l,i+3,F);if(Q){const o=t.Cartesian3.fromArray(l,i+d,R);_&&O(n,e,o,f),t.Cartesian3.subtract(e,n,e),t.Cartesian3.subtract(o,n,o),v=t.Cartesian3.normalize(t.Cartesian3.cross(o,e,v),v),Q=!1}t.Cartesian3.equalsEpsilon(e,n,a.CesiumMath.EPSILON10)&&(Q=!0)}(r.tangent||r.bitangent)&&(H=f.geodeticSurfaceNormal(n,H),r.tangent&&(G=t.Cartesian3.normalize(t.Cartesian3.cross(H,v,G),G)))}else v=f.geodeticSurfaceNormal(n,v),(r.tangent||r.bitangent)&&(_&&(M=t.Cartesian3.fromArray(x,E,M),k=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,M,k),k=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(K,k,k),k),r.bitangent&&(S=t.Cartesian3.normalize(t.Cartesian3.cross(M,k,S),S))),G=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,v,G),G=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(K,G,G),G),r.bitangent&&(H=t.Cartesian3.normalize(t.Cartesian3.cross(v,G,H),H)));r.normal&&(o.wall?(x[E+Z]=v.x,x[e+Z]=v.y,x[c+Z]=v.z):m&&(x[E+Z]=-v.x,x[e+Z]=-v.y,x[c+Z]=-v.z),(g&&!_||y)&&(x[E]=v.x,x[e]=v.y,x[c]=v.z)),s&&(y&&(v=f.geodeticSurfaceNormal(n,v)),A[E+Z]=-v.x,A[e+Z]=-v.y,A[c+Z]=-v.z),r.tangent&&(o.wall?(T[E+Z]=G.x,T[e+Z]=G.y,T[c+Z]=G.z):m&&(T[E+Z]=-G.x,T[e+Z]=-G.y,T[c+Z]=-G.z),g&&(_?(T[E]=k.x,T[e]=k.y,T[c]=k.z):(T[E]=G.x,T[e]=G.y,T[c]=G.z))),r.bitangent&&(m&&(w[E+Z]=H.x,w[e+Z]=H.y,w[c+Z]=H.z),g&&(_?(w[E]=S.x,w[e]=S.y,w[c]=S.z):(w[E]=H.x,w[e]=H.y,w[c]=H.z))),E+=3}}r.st&&!e.defined(u)&&(n.attributes.st=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:P})),r.normal&&(n.attributes.normal=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x})),r.tangent&&(n.attributes.tangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),r.bitangent&&(n.attributes.bitangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),s&&(n.attributes.extrudeDirection=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A}))}if(o.extrude&&e.defined(o.offsetAttribute)){const e=l.length/3;let t=new Uint8Array(e);if(o.offsetAttribute===p.GeometryOffsetAttribute.TOP)g&&m||y?t=t.fill(1,0,e/2):g&&(t=t.fill(1));else{const e=o.offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1;t=t.fill(e)}n.attributes.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return n}const q=new t.Cartographic,K=new t.Cartographic,Z={westOverIDL:0,eastOverIDL:0};let J=new s.EllipsoidGeodesic;function X(r,i,n,l,c){if(c=e.defaultValue(c,new t.Rectangle),!e.defined(r)||r.length<3)return c.west=0,c.north=0,c.south=0,c.east=0,c;if(n===o.ArcType.RHUMB)return t.Rectangle.fromCartesianArray(r,i,c);J.ellipsoid.equals(i)||(J=new s.EllipsoidGeodesic(void 0,void 0,i)),c.west=Number.POSITIVE_INFINITY,c.east=Number.NEGATIVE_INFINITY,c.south=Number.POSITIVE_INFINITY,c.north=Number.NEGATIVE_INFINITY,Z.westOverIDL=Number.POSITIVE_INFINITY,Z.eastOverIDL=Number.NEGATIVE_INFINITY;const u=1/a.CesiumMath.chordLength(l,i.maximumRadius),p=r.length;let d,y=i.cartesianToCartographic(r[0],K),g=q;for(let e=1;e<p;e++)d=g,g=y,y=i.cartesianToCartographic(r[e],d),J.setEndPoints(g,y),ee(J,u,c,Z);return d=g,g=y,y=i.cartesianToCartographic(r[0],d),J.setEndPoints(g,y),ee(J,u,c,Z),c.east-c.west>Z.eastOverIDL-Z.westOverIDL&&(c.west=Z.westOverIDL,c.east=Z.eastOverIDL,c.east>a.CesiumMath.PI&&(c.east=c.east-a.CesiumMath.TWO_PI),c.west>a.CesiumMath.PI&&(c.west=c.west-a.CesiumMath.TWO_PI)),c}const $=new t.Cartographic;function ee(e,t,o,r){const i=e.surfaceDistance,n=Math.ceil(i*t),s=n>0?i/(n-1):Number.POSITIVE_INFINITY;let l=0;for(let t=0;t<n;t++){const t=e.interpolateUsingSurfaceDistance(l,$);l+=s;const i=t.longitude,n=t.latitude;o.west=Math.min(o.west,i),o.east=Math.max(o.east,i),o.south=Math.min(o.south,n),o.north=Math.max(o.north,n);const c=i>=0?i:i+a.CesiumMath.TWO_PI;r.westOverIDL=Math.min(r.westOverIDL,c),r.eastOverIDL=Math.max(r.eastOverIDL,c)}}const te=[];function oe(t,o,r,i,n,a,s,c,p,d){const h={walls:[]};let f;if(s||c){const n=g.PolygonGeometryLibrary.createGeometryFromPositions(t,o,r,i,a,p,d),l=n.attributes.position.values,m=n.indices;let b,_;if(s&&c){const t=l.concat(l);b=t.length/3,_=y.IndexDatatype.createTypedArray(b,2*m.length),_.set(m);const o=m.length,i=b/2;for(f=0;f<o;f+=3){const e=_[f]+i,t=_[f+1]+i,r=_[f+2]+i;_[f+o]=r,_[f+1+o]=t,_[f+2+o]=e}if(n.attributes.position.values=t,a&&p.normal){const e=n.attributes.normal.values;n.attributes.normal.values=new Float32Array(t.length),n.attributes.normal.values.set(e)}if(p.st&&e.defined(r)){const e=n.attributes.st.values;n.attributes.st.values=new Float32Array(2*b),n.attributes.st.values=e.concat(e)}n.indices=_}else if(c){for(b=l.length/3,_=y.IndexDatatype.createTypedArray(b,m.length),f=0;f<m.length;f+=3)_[f]=m[f+2],_[f+1]=m[f+1],_[f+2]=m[f];n.indices=_}h.topAndBottom=new u.GeometryInstance({geometry:n})}let b=n.outerRing,_=l.EllipsoidTangentPlane.fromPoints(b,t),C=_.projectPointsOntoPlane(b,te),P=m.PolygonPipeline.computeWindingOrder2D(C);P===m.WindingOrder.CLOCKWISE&&(b=b.slice().reverse());let x=g.PolygonGeometryLibrary.computeWallGeometry(b,r,t,i,a,d);h.walls.push(new u.GeometryInstance({geometry:x}));const T=n.holes;for(f=0;f<T.length;f++){let e=T[f];_=l.EllipsoidTangentPlane.fromPoints(e,t),C=_.projectPointsOntoPlane(e,te),P=m.PolygonPipeline.computeWindingOrder2D(C),P===m.WindingOrder.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),x=g.PolygonGeometryLibrary.computeWallGeometry(e,r,t,i,a,d),h.walls.push(new u.GeometryInstance({geometry:x}))}return h}function re(r){if(n.Check.typeOf.object("options",r),n.Check.typeOf.object("options.polygonHierarchy",r.polygonHierarchy),e.defined(r.perPositionHeight)&&r.perPositionHeight&&e.defined(r.height))throw new n.DeveloperError("Cannot use both options.perPositionHeight and options.height");if(e.defined(r.arcType)&&r.arcType!==o.ArcType.GEODESIC&&r.arcType!==o.ArcType.RHUMB)throw new n.DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const i=r.polygonHierarchy,s=e.defaultValue(r.vertexFormat,h.VertexFormat.DEFAULT),l=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84),c=e.defaultValue(r.granularity,a.CesiumMath.RADIANS_PER_DEGREE),u=e.defaultValue(r.stRotation,0),p=r.textureCoordinates,d=e.defaultValue(r.perPositionHeight,!1),y=d&&e.defined(r.extrudedHeight);let m=e.defaultValue(r.height,0),f=e.defaultValue(r.extrudedHeight,m);if(!y){const e=Math.max(m,f);f=Math.min(m,f),m=e}this._vertexFormat=h.VertexFormat.clone(s),this._ellipsoid=t.Ellipsoid.clone(l),this._granularity=c,this._stRotation=u,this._height=m,this._extrudedHeight=f,this._closeTop=e.defaultValue(r.closeTop,!0),this._closeBottom=e.defaultValue(r.closeBottom,!0),this._polygonHierarchy=i,this._perPositionHeight=d,this._perPositionHeightExtrude=y,this._shadowVolume=e.defaultValue(r.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=r.offsetAttribute,this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=p,this.packedLength=g.PolygonGeometryLibrary.computeHierarchyPackedLength(i,t.Cartesian3)+t.Ellipsoid.packedLength+h.VertexFormat.packedLength+(p?g.PolygonGeometryLibrary.computeHierarchyPackedLength(p,t.Cartesian2):1)+12}re.fromPositions=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT),n.Check.defined("options.positions",t.positions);return new re({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},re.pack=function(o,r,i){return n.Check.typeOf.object("value",o),n.Check.defined("array",r),i=e.defaultValue(i,0),i=g.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,r,i,t.Cartesian3),t.Ellipsoid.pack(o._ellipsoid,r,i),i+=t.Ellipsoid.packedLength,h.VertexFormat.pack(o._vertexFormat,r,i),i+=h.VertexFormat.packedLength,r[i++]=o._height,r[i++]=o._extrudedHeight,r[i++]=o._granularity,r[i++]=o._stRotation,r[i++]=o._perPositionHeightExtrude?1:0,r[i++]=o._perPositionHeight?1:0,r[i++]=o._closeTop?1:0,r[i++]=o._closeBottom?1:0,r[i++]=o._shadowVolume?1:0,r[i++]=e.defaultValue(o._offsetAttribute,-1),r[i++]=o._arcType,e.defined(o._textureCoordinates)?i=g.PolygonGeometryLibrary.packPolygonHierarchy(o._textureCoordinates,r,i,t.Cartesian2):r[i++]=-1,r[i++]=o.packedLength,r};const ie=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),ne=new h.VertexFormat,ae={polygonHierarchy:{}};return re.unpack=function(o,r,i){n.Check.defined("array",o),r=e.defaultValue(r,0);const a=g.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,t.Cartesian3);r=a.startingIndex,delete a.startingIndex;const s=t.Ellipsoid.unpack(o,r,ie);r+=t.Ellipsoid.packedLength;const l=h.VertexFormat.unpack(o,r,ne);r+=h.VertexFormat.packedLength;const c=o[r++],u=o[r++],p=o[r++],d=o[r++],y=1===o[r++],m=1===o[r++],f=1===o[r++],b=1===o[r++],_=1===o[r++],C=o[r++],P=o[r++],x=-1===o[r]?void 0:g.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,t.Cartesian2);e.defined(x)?(r=x.startingIndex,delete x.startingIndex):r++;const T=o[r++];return e.defined(i)||(i=new re(ae)),i._polygonHierarchy=a,i._ellipsoid=t.Ellipsoid.clone(s,i._ellipsoid),i._vertexFormat=h.VertexFormat.clone(l,i._vertexFormat),i._height=c,i._extrudedHeight=u,i._granularity=p,i._stRotation=d,i._perPositionHeightExtrude=y,i._perPositionHeight=m,i._closeTop=f,i._closeBottom=b,i._shadowVolume=_,i._offsetAttribute=-1===C?void 0:C,i._arcType=P,i._textureCoordinates=x,i.packedLength=T,i},re.computeRectangle=function(r,i){n.Check.typeOf.object("options",r),n.Check.typeOf.object("options.polygonHierarchy",r.polygonHierarchy);const s=e.defaultValue(r.granularity,a.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(r.arcType,o.ArcType.GEODESIC);if(l!==o.ArcType.GEODESIC&&l!==o.ArcType.RHUMB)throw new n.DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const c=r.polygonHierarchy,u=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84);return X(c.positions,u,l,s,i)},re.createGeometry=function(t){const o=t._vertexFormat,r=t._ellipsoid,n=t._granularity,s=t._stRotation,h=t._polygonHierarchy,f=t._perPositionHeight,b=t._closeTop,_=t._closeBottom,C=t._arcType,P=t._textureCoordinates,x=e.defined(P);let T=h.positions;if(T.length<3)return;const w=l.EllipsoidTangentPlane.fromPoints(T,r),A=g.PolygonGeometryLibrary.polygonsFromHierarchy(h,x,w.projectPointsOntoPlane.bind(w),!f,r),I=A.hierarchy,E=A.polygons,v=x?g.PolygonGeometryLibrary.polygonsFromHierarchy(P,!0,(function(e){return e}),!1).polygons:void 0;if(0===I.length)return;T=I[0].outerRing;const G=g.PolygonGeometryLibrary.computeBoundingRectangle(w.plane.normal,w.projectPointOntoPlane.bind(w),T,s,H),O=[],D=t._height,V=t._extrudedHeight,L={perPositionHeight:f,vertexFormat:o,geometry:void 0,tangentPlane:w,boundingRectangle:G,ellipsoid:r,stRotation:s,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:C};let N;if(t._perPositionHeightExtrude||!a.CesiumMath.equalsEpsilon(D,V,0,a.CesiumMath.EPSILON2))for(L.extrude=!0,L.top=b,L.bottom=_,L.shadowVolume=t._shadowVolume,L.offsetAttribute=t._offsetAttribute,N=0;N<E.length;N++){const e=oe(r,E[N],x?v[N]:void 0,n,I[N],f,b,_,o,C);let t;b&&_?(t=e.topAndBottom,L.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,D,V,r,f)):b?(t=e.topAndBottom,t.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,D,r,!f),L.geometry=t.geometry):_&&(t=e.topAndBottom,t.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,V,r,!0),L.geometry=t.geometry),(b||_)&&(L.wall=!1,t.geometry=Q(L),O.push(t));const i=e.walls;L.wall=!0;for(let e=0;e<i.length;e++){const t=i[e];L.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,D,V,r,f),t.geometry=Q(L),O.push(t)}}else for(N=0;N<E.length;N++){const i=new u.GeometryInstance({geometry:g.PolygonGeometryLibrary.createGeometryFromPositions(r,E[N],x?v[N]:void 0,n,f,o,C)});if(i.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(i.geometry.attributes.position.values,D,r,!f),L.geometry=i.geometry,i.geometry=Q(L),e.defined(t._offsetAttribute)){const e=i.geometry.attributes.position.values.length,o=t._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1,r=new Uint8Array(e/3).fill(o);i.geometry.attributes.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}O.push(i)}const F=d.GeometryPipeline.combineInstances(O)[0];F.attributes.position.values=new Float64Array(F.attributes.position.values),F.indices=y.IndexDatatype.createTypedArray(F.attributes.position.values.length/3,F.indices);const R=F.attributes,M=i.BoundingSphere.fromVertices(R.position.values);return o.position||delete R.position,new c.Geometry({attributes:R,indices:F.indices,primitiveType:F.primitiveType,boundingSphere:M,offsetAttribute:t._offsetAttribute})},re.createShadowVolume=function(e,t,o){const r=e._granularity,i=e._ellipsoid,n=t(r,i),a=o(r,i);return new re({polygonHierarchy:e._polygonHierarchy,ellipsoid:i,stRotation:e._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:n,height:a,vertexFormat:h.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(re.prototype,{rectangle:{get:function(){if(!e.defined(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=X(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return e.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const o=e._ellipsoid,r=e._polygonHierarchy.positions,i=e.rectangle;return c.Geometry._textureCoordinateRotationPoints(r,t,o,i)}(this)),this._textureCoordinateRotationPoints}}}),function(o,r){return e.defined(r)&&(o=re.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),re.createGeometry(o)}}));
//# sourceMappingURL=createPolygonGeometry.js.map
