{"version":3,"file":"createPolygonGeometry.js","sources":["../../../../Source/Core/PolygonGeometry.js","../../../../Source/WorkersES6/createPolygonGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\r\nimport BoundingRectangle from \"./BoundingRectangle.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryInstance from \"./GeometryInstance.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport GeometryPipeline from \"./GeometryPipeline.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\nimport WindingOrder from \"./WindingOrder.js\";\r\n\r\nconst scratchCarto1 = new Cartographic();\r\nconst scratchCarto2 = new Cartographic();\r\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\r\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\r\n  const height = carto1.height;\r\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\r\n  p1Carto.height = height;\r\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\r\n\r\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\r\n  p2Carto.height = height - 100;\r\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\r\n}\r\n\r\nconst scratchBoundingRectangle = new BoundingRectangle();\r\nconst scratchPosition = new Cartesian3();\r\nconst scratchNormal = new Cartesian3();\r\nconst scratchTangent = new Cartesian3();\r\nconst scratchBitangent = new Cartesian3();\r\nconst p1Scratch = new Cartesian3();\r\nconst p2Scratch = new Cartesian3();\r\nlet scratchPerPosNormal = new Cartesian3();\r\nlet scratchPerPosTangent = new Cartesian3();\r\nlet scratchPerPosBitangent = new Cartesian3();\r\n\r\nconst appendTextureCoordinatesOrigin = new Cartesian2();\r\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\r\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\r\nconst appendTextureCoordinatesQuaternion = new Quaternion();\r\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\r\nconst tangentMatrixScratch = new Matrix3();\r\n\r\nfunction computeAttributes(options) {\r\n  const vertexFormat = options.vertexFormat;\r\n  const geometry = options.geometry;\r\n  const shadowVolume = options.shadowVolume;\r\n  const flatPositions = geometry.attributes.position.values;\r\n  const flatTexcoords = defined(geometry.attributes.st)\r\n    ? geometry.attributes.st.values\r\n    : undefined;\r\n\r\n  let length = flatPositions.length;\r\n  const wall = options.wall;\r\n  const top = options.top || wall;\r\n  const bottom = options.bottom || wall;\r\n  if (\r\n    vertexFormat.st ||\r\n    vertexFormat.normal ||\r\n    vertexFormat.tangent ||\r\n    vertexFormat.bitangent ||\r\n    shadowVolume\r\n  ) {\r\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\r\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\r\n    const boundingRectangle = options.boundingRectangle;\r\n    const tangentPlane = options.tangentPlane;\r\n    const ellipsoid = options.ellipsoid;\r\n    const stRotation = options.stRotation;\r\n    const perPositionHeight = options.perPositionHeight;\r\n\r\n    const origin = appendTextureCoordinatesOrigin;\r\n    origin.x = boundingRectangle.x;\r\n    origin.y = boundingRectangle.y;\r\n\r\n    const textureCoordinates = vertexFormat.st\r\n      ? new Float32Array(2 * (length / 3))\r\n      : undefined;\r\n    let normals;\r\n    if (vertexFormat.normal) {\r\n      if (perPositionHeight && top && !wall) {\r\n        normals = geometry.attributes.normal.values;\r\n      } else {\r\n        normals = new Float32Array(length);\r\n      }\r\n    }\r\n    const tangents = vertexFormat.tangent\r\n      ? new Float32Array(length)\r\n      : undefined;\r\n    const bitangents = vertexFormat.bitangent\r\n      ? new Float32Array(length)\r\n      : undefined;\r\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\r\n\r\n    let textureCoordIndex = 0;\r\n    let attrIndex = 0;\r\n\r\n    let normal = scratchNormal;\r\n    let tangent = scratchTangent;\r\n    let bitangent = scratchBitangent;\r\n    let recomputeNormal = true;\r\n\r\n    let textureMatrix = appendTextureCoordinatesMatrix3;\r\n    let tangentRotationMatrix = tangentMatrixScratch;\r\n    if (stRotation !== 0.0) {\r\n      let rotation = Quaternion.fromAxisAngle(\r\n        tangentPlane._plane.normal,\r\n        stRotation,\r\n        appendTextureCoordinatesQuaternion\r\n      );\r\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\r\n\r\n      rotation = Quaternion.fromAxisAngle(\r\n        tangentPlane._plane.normal,\r\n        -stRotation,\r\n        appendTextureCoordinatesQuaternion\r\n      );\r\n      tangentRotationMatrix = Matrix3.fromQuaternion(\r\n        rotation,\r\n        tangentRotationMatrix\r\n      );\r\n    } else {\r\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\r\n      tangentRotationMatrix = Matrix3.clone(\r\n        Matrix3.IDENTITY,\r\n        tangentRotationMatrix\r\n      );\r\n    }\r\n\r\n    let bottomOffset = 0;\r\n    let bottomOffset2 = 0;\r\n\r\n    if (top && bottom) {\r\n      bottomOffset = length / 2;\r\n      bottomOffset2 = length / 3;\r\n\r\n      length /= 2;\r\n    }\r\n\r\n    for (let i = 0; i < length; i += 3) {\r\n      const position = Cartesian3.fromArray(\r\n        flatPositions,\r\n        i,\r\n        appendTextureCoordinatesCartesian3\r\n      );\r\n\r\n      if (vertexFormat.st) {\r\n        if (!defined(flatTexcoords)) {\r\n          let p = Matrix3.multiplyByVector(\r\n            textureMatrix,\r\n            position,\r\n            scratchPosition\r\n          );\r\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\r\n          const st = tangentPlane.projectPointOntoPlane(\r\n            p,\r\n            appendTextureCoordinatesCartesian2\r\n          );\r\n          Cartesian2.subtract(st, origin, st);\r\n\r\n          const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\r\n          const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\r\n          if (bottom) {\r\n            textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\r\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\r\n          }\r\n          if (top) {\r\n            textureCoordinates[textureCoordIndex] = stx;\r\n            textureCoordinates[textureCoordIndex + 1] = sty;\r\n          }\r\n\r\n          textureCoordIndex += 2;\r\n        }\r\n      }\r\n\r\n      if (\r\n        vertexFormat.normal ||\r\n        vertexFormat.tangent ||\r\n        vertexFormat.bitangent ||\r\n        shadowVolume\r\n      ) {\r\n        const attrIndex1 = attrIndex + 1;\r\n        const attrIndex2 = attrIndex + 2;\r\n\r\n        if (wall) {\r\n          if (i + 3 < length) {\r\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\r\n\r\n            if (recomputeNormal) {\r\n              const p2 = Cartesian3.fromArray(\r\n                flatPositions,\r\n                i + length,\r\n                p2Scratch\r\n              );\r\n              if (perPositionHeight) {\r\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\r\n              }\r\n              Cartesian3.subtract(p1, position, p1);\r\n              Cartesian3.subtract(p2, position, p2);\r\n              normal = Cartesian3.normalize(\r\n                Cartesian3.cross(p2, p1, normal),\r\n                normal\r\n              );\r\n              recomputeNormal = false;\r\n            }\r\n\r\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\r\n              // if we've reached a corner\r\n              recomputeNormal = true;\r\n            }\r\n          }\r\n\r\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\r\n            if (vertexFormat.tangent) {\r\n              tangent = Cartesian3.normalize(\r\n                Cartesian3.cross(bitangent, normal, tangent),\r\n                tangent\r\n              );\r\n            }\r\n          }\r\n        } else {\r\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            if (perPositionHeight) {\r\n              scratchPerPosNormal = Cartesian3.fromArray(\r\n                normals,\r\n                attrIndex,\r\n                scratchPerPosNormal\r\n              );\r\n              scratchPerPosTangent = Cartesian3.cross(\r\n                Cartesian3.UNIT_Z,\r\n                scratchPerPosNormal,\r\n                scratchPerPosTangent\r\n              );\r\n              scratchPerPosTangent = Cartesian3.normalize(\r\n                Matrix3.multiplyByVector(\r\n                  tangentRotationMatrix,\r\n                  scratchPerPosTangent,\r\n                  scratchPerPosTangent\r\n                ),\r\n                scratchPerPosTangent\r\n              );\r\n              if (vertexFormat.bitangent) {\r\n                scratchPerPosBitangent = Cartesian3.normalize(\r\n                  Cartesian3.cross(\r\n                    scratchPerPosNormal,\r\n                    scratchPerPosTangent,\r\n                    scratchPerPosBitangent\r\n                  ),\r\n                  scratchPerPosBitangent\r\n                );\r\n              }\r\n            }\r\n\r\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\r\n            tangent = Cartesian3.normalize(\r\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\r\n              tangent\r\n            );\r\n            if (vertexFormat.bitangent) {\r\n              bitangent = Cartesian3.normalize(\r\n                Cartesian3.cross(normal, tangent, bitangent),\r\n                bitangent\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n          if (options.wall) {\r\n            normals[attrIndex + bottomOffset] = normal.x;\r\n            normals[attrIndex1 + bottomOffset] = normal.y;\r\n            normals[attrIndex2 + bottomOffset] = normal.z;\r\n          } else if (bottom) {\r\n            normals[attrIndex + bottomOffset] = -normal.x;\r\n            normals[attrIndex1 + bottomOffset] = -normal.y;\r\n            normals[attrIndex2 + bottomOffset] = -normal.z;\r\n          }\r\n\r\n          if ((top && !perPositionHeight) || wall) {\r\n            normals[attrIndex] = normal.x;\r\n            normals[attrIndex1] = normal.y;\r\n            normals[attrIndex2] = normal.z;\r\n          }\r\n        }\r\n\r\n        if (shadowVolume) {\r\n          if (wall) {\r\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n          }\r\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\r\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\r\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n          if (options.wall) {\r\n            tangents[attrIndex + bottomOffset] = tangent.x;\r\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\r\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\r\n          } else if (bottom) {\r\n            tangents[attrIndex + bottomOffset] = -tangent.x;\r\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\r\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\r\n          }\r\n\r\n          if (top) {\r\n            if (perPositionHeight) {\r\n              tangents[attrIndex] = scratchPerPosTangent.x;\r\n              tangents[attrIndex1] = scratchPerPosTangent.y;\r\n              tangents[attrIndex2] = scratchPerPosTangent.z;\r\n            } else {\r\n              tangents[attrIndex] = tangent.x;\r\n              tangents[attrIndex1] = tangent.y;\r\n              tangents[attrIndex2] = tangent.z;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n          if (bottom) {\r\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\r\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\r\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\r\n          }\r\n          if (top) {\r\n            if (perPositionHeight) {\r\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\r\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\r\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\r\n            } else {\r\n              bitangents[attrIndex] = bitangent.x;\r\n              bitangents[attrIndex1] = bitangent.y;\r\n              bitangents[attrIndex2] = bitangent.z;\r\n            }\r\n          }\r\n        }\r\n        attrIndex += 3;\r\n      }\r\n    }\r\n\r\n    if (vertexFormat.st && !defined(flatTexcoords)) {\r\n      geometry.attributes.st = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 2,\r\n        values: textureCoordinates,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.normal) {\r\n      geometry.attributes.normal = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: normals,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.tangent) {\r\n      geometry.attributes.tangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: tangents,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.bitangent) {\r\n      geometry.attributes.bitangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: bitangents,\r\n      });\r\n    }\r\n\r\n    if (shadowVolume) {\r\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: extrudeNormals,\r\n      });\r\n    }\r\n  }\r\n\r\n  if (options.extrude && defined(options.offsetAttribute)) {\r\n    const size = flatPositions.length / 3;\r\n    let offsetAttribute = new Uint8Array(size);\r\n\r\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n      if ((top && bottom) || wall) {\r\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\r\n      } else if (top) {\r\n        offsetAttribute = offsetAttribute.fill(1);\r\n      }\r\n    } else {\r\n      const offsetValue =\r\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n      offsetAttribute = offsetAttribute.fill(offsetValue);\r\n    }\r\n\r\n    geometry.attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: offsetAttribute,\r\n    });\r\n  }\r\n\r\n  return geometry;\r\n}\r\n\r\nconst startCartographicScratch = new Cartographic();\r\nconst endCartographicScratch = new Cartographic();\r\nconst idlCross = {\r\n  westOverIDL: 0.0,\r\n  eastOverIDL: 0.0,\r\n};\r\nlet ellipsoidGeodesic = new EllipsoidGeodesic();\r\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\r\n  result = defaultValue(result, new Rectangle());\r\n  if (!defined(positions) || positions.length < 3) {\r\n    result.west = 0.0;\r\n    result.north = 0.0;\r\n    result.south = 0.0;\r\n    result.east = 0.0;\r\n    return result;\r\n  }\r\n\r\n  if (arcType === ArcType.RHUMB) {\r\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\r\n  }\r\n\r\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\r\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\r\n  }\r\n\r\n  result.west = Number.POSITIVE_INFINITY;\r\n  result.east = Number.NEGATIVE_INFINITY;\r\n  result.south = Number.POSITIVE_INFINITY;\r\n  result.north = Number.NEGATIVE_INFINITY;\r\n\r\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\r\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\r\n\r\n  const inverseChordLength =\r\n    1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n  const positionsLength = positions.length;\r\n  let endCartographic = ellipsoid.cartesianToCartographic(\r\n    positions[0],\r\n    endCartographicScratch\r\n  );\r\n  let startCartographic = startCartographicScratch;\r\n  let swap;\r\n\r\n  for (let i = 1; i < positionsLength; i++) {\r\n    swap = startCartographic;\r\n    startCartographic = endCartographic;\r\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\r\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n    interpolateAndGrowRectangle(\r\n      ellipsoidGeodesic,\r\n      inverseChordLength,\r\n      result,\r\n      idlCross\r\n    );\r\n  }\r\n\r\n  swap = startCartographic;\r\n  startCartographic = endCartographic;\r\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\r\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n  interpolateAndGrowRectangle(\r\n    ellipsoidGeodesic,\r\n    inverseChordLength,\r\n    result,\r\n    idlCross\r\n  );\r\n\r\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\r\n    result.west = idlCross.westOverIDL;\r\n    result.east = idlCross.eastOverIDL;\r\n\r\n    if (result.east > CesiumMath.PI) {\r\n      result.east = result.east - CesiumMath.TWO_PI;\r\n    }\r\n    if (result.west > CesiumMath.PI) {\r\n      result.west = result.west - CesiumMath.TWO_PI;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst interpolatedCartographicScratch = new Cartographic();\r\nfunction interpolateAndGrowRectangle(\r\n  ellipsoidGeodesic,\r\n  inverseChordLength,\r\n  result,\r\n  idlCross\r\n) {\r\n  const segmentLength = ellipsoidGeodesic.surfaceDistance;\r\n\r\n  const numPoints = Math.ceil(segmentLength * inverseChordLength);\r\n  const subsegmentDistance =\r\n    numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\r\n  let interpolationDistance = 0.0;\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    const interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\r\n      interpolationDistance,\r\n      interpolatedCartographicScratch\r\n    );\r\n    interpolationDistance += subsegmentDistance;\r\n    const longitude = interpolatedCartographic.longitude;\r\n    const latitude = interpolatedCartographic.latitude;\r\n\r\n    result.west = Math.min(result.west, longitude);\r\n    result.east = Math.max(result.east, longitude);\r\n    result.south = Math.min(result.south, latitude);\r\n    result.north = Math.max(result.north, latitude);\r\n\r\n    const lonAdjusted =\r\n      longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\r\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\r\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\r\n  }\r\n}\r\n\r\nconst createGeometryFromPositionsExtrudedPositions = [];\r\n\r\nfunction createGeometryFromPositionsExtruded(\r\n  ellipsoid,\r\n  polygon,\r\n  textureCoordinates,\r\n  granularity,\r\n  hierarchy,\r\n  perPositionHeight,\r\n  closeTop,\r\n  closeBottom,\r\n  vertexFormat,\r\n  arcType\r\n) {\r\n  const geos = {\r\n    walls: [],\r\n  };\r\n  let i;\r\n\r\n  if (closeTop || closeBottom) {\r\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\r\n      ellipsoid,\r\n      polygon,\r\n      textureCoordinates,\r\n      granularity,\r\n      perPositionHeight,\r\n      vertexFormat,\r\n      arcType\r\n    );\r\n\r\n    const edgePoints = topGeo.attributes.position.values;\r\n    const indices = topGeo.indices;\r\n    let numPositions;\r\n    let newIndices;\r\n\r\n    if (closeTop && closeBottom) {\r\n      const topBottomPositions = edgePoints.concat(edgePoints);\r\n\r\n      numPositions = topBottomPositions.length / 3;\r\n\r\n      newIndices = IndexDatatype.createTypedArray(\r\n        numPositions,\r\n        indices.length * 2\r\n      );\r\n      newIndices.set(indices);\r\n      const ilength = indices.length;\r\n\r\n      const length = numPositions / 2;\r\n\r\n      for (i = 0; i < ilength; i += 3) {\r\n        const i0 = newIndices[i] + length;\r\n        const i1 = newIndices[i + 1] + length;\r\n        const i2 = newIndices[i + 2] + length;\r\n\r\n        newIndices[i + ilength] = i2;\r\n        newIndices[i + 1 + ilength] = i1;\r\n        newIndices[i + 2 + ilength] = i0;\r\n      }\r\n\r\n      topGeo.attributes.position.values = topBottomPositions;\r\n      if (perPositionHeight && vertexFormat.normal) {\r\n        const normals = topGeo.attributes.normal.values;\r\n        topGeo.attributes.normal.values = new Float32Array(\r\n          topBottomPositions.length\r\n        );\r\n        topGeo.attributes.normal.values.set(normals);\r\n      }\r\n\r\n      if (vertexFormat.st && defined(textureCoordinates)) {\r\n        const texcoords = topGeo.attributes.st.values;\r\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\r\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\r\n      }\r\n\r\n      topGeo.indices = newIndices;\r\n    } else if (closeBottom) {\r\n      numPositions = edgePoints.length / 3;\r\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\r\n\r\n      for (i = 0; i < indices.length; i += 3) {\r\n        newIndices[i] = indices[i + 2];\r\n        newIndices[i + 1] = indices[i + 1];\r\n        newIndices[i + 2] = indices[i];\r\n      }\r\n\r\n      topGeo.indices = newIndices;\r\n    }\r\n\r\n    geos.topAndBottom = new GeometryInstance({\r\n      geometry: topGeo,\r\n    });\r\n  }\r\n\r\n  let outerRing = hierarchy.outerRing;\r\n  let tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\r\n  let positions2D = tangentPlane.projectPointsOntoPlane(\r\n    outerRing,\r\n    createGeometryFromPositionsExtrudedPositions\r\n  );\r\n\r\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n  if (windingOrder === WindingOrder.CLOCKWISE) {\r\n    outerRing = outerRing.slice().reverse();\r\n  }\r\n\r\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(\r\n    outerRing,\r\n    textureCoordinates,\r\n    ellipsoid,\r\n    granularity,\r\n    perPositionHeight,\r\n    arcType\r\n  );\r\n  geos.walls.push(\r\n    new GeometryInstance({\r\n      geometry: wallGeo,\r\n    })\r\n  );\r\n\r\n  const holes = hierarchy.holes;\r\n  for (i = 0; i < holes.length; i++) {\r\n    let hole = holes[i];\r\n\r\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\r\n    positions2D = tangentPlane.projectPointsOntoPlane(\r\n      hole,\r\n      createGeometryFromPositionsExtrudedPositions\r\n    );\r\n\r\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\r\n      hole = hole.slice().reverse();\r\n    }\r\n\r\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\r\n      hole,\r\n      textureCoordinates,\r\n      ellipsoid,\r\n      granularity,\r\n      perPositionHeight,\r\n      arcType\r\n    );\r\n    geos.walls.push(\r\n      new GeometryInstance({\r\n        geometry: wallGeo,\r\n      })\r\n    );\r\n  }\r\n\r\n  return geos;\r\n}\r\n\r\n/**\r\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @alias PolygonGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\r\n *\r\n * @see PolygonGeometry#createGeometry\r\n * @see PolygonGeometry#fromPositions\r\n *\r\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\r\n *\r\n * @example\r\n * // 1. create a polygon from points\r\n * const polygon = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n *\r\n * // 2. create a nested polygon with holes\r\n * const polygonWithHole = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -109.0, 30.0,\r\n *       -95.0, 30.0,\r\n *       -95.0, 40.0,\r\n *       -109.0, 40.0\r\n *     ]),\r\n *     [new Cesium.PolygonHierarchy(\r\n *       Cesium.Cartesian3.fromDegreesArray([\r\n *         -107.0, 31.0,\r\n *         -107.0, 39.0,\r\n *         -97.0, 39.0,\r\n *         -97.0, 31.0\r\n *       ]),\r\n *       [new Cesium.PolygonHierarchy(\r\n *         Cesium.Cartesian3.fromDegreesArray([\r\n *           -105.0, 33.0,\r\n *           -99.0, 33.0,\r\n *           -99.0, 37.0,\r\n *           -105.0, 37.0\r\n *         ]),\r\n *         [new Cesium.PolygonHierarchy(\r\n *           Cesium.Cartesian3.fromDegreesArray([\r\n *             -103.0, 34.0,\r\n *             -101.0, 34.0,\r\n *             -101.0, 36.0,\r\n *             -103.0, 36.0\r\n *           ])\r\n *         )]\r\n *       )]\r\n *     )]\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\r\n *\r\n * // 3. create extruded polygon\r\n * const extrudedPolygon = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   ),\r\n *   extrudedHeight: 300000\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\r\n */\r\nfunction PolygonGeometry(options) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n  if (\r\n    defined(options.perPositionHeight) &&\r\n    options.perPositionHeight &&\r\n    defined(options.height)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Cannot use both options.perPositionHeight and options.height\"\r\n    );\r\n  }\r\n  if (\r\n    defined(options.arcType) &&\r\n    options.arcType !== ArcType.GEODESIC &&\r\n    options.arcType !== ArcType.RHUMB\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const stRotation = defaultValue(options.stRotation, 0.0);\r\n  const textureCoordinates = options.textureCoordinates;\r\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\r\n  const perPositionHeightExtrude =\r\n    perPositionHeight && defined(options.extrudedHeight);\r\n  let height = defaultValue(options.height, 0.0);\r\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  if (!perPositionHeightExtrude) {\r\n    const h = Math.max(height, extrudedHeight);\r\n    extrudedHeight = Math.min(height, extrudedHeight);\r\n    height = h;\r\n  }\r\n\r\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n  this._granularity = granularity;\r\n  this._stRotation = stRotation;\r\n  this._height = height;\r\n  this._extrudedHeight = extrudedHeight;\r\n  this._closeTop = defaultValue(options.closeTop, true);\r\n  this._closeBottom = defaultValue(options.closeBottom, true);\r\n  this._polygonHierarchy = polygonHierarchy;\r\n  this._perPositionHeight = perPositionHeight;\r\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n  this._workerName = \"createPolygonGeometry\";\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n  this._rectangle = undefined;\r\n  this._textureCoordinateRotationPoints = undefined;\r\n  this._textureCoordinates = textureCoordinates;\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n      polygonHierarchy,\r\n      Cartesian3\r\n    ) +\r\n    Ellipsoid.packedLength +\r\n    VertexFormat.packedLength +\r\n    (textureCoordinates\r\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n          textureCoordinates,\r\n          Cartesian2\r\n        )\r\n      : 1) +\r\n    12;\r\n}\r\n\r\n/**\r\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\r\n * @param {Number} [options.height=0.0] The height of the polygon.\r\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\r\n * @returns {PolygonGeometry}\r\n *\r\n * @example\r\n * // create a polygon from points\r\n * const polygon = Cesium.PolygonGeometry.fromPositions({\r\n *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n *     -72.0, 40.0,\r\n *     -70.0, 35.0,\r\n *     -75.0, 30.0,\r\n *     -70.0, 30.0,\r\n *     -68.0, 40.0\r\n *   ])\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n *\r\n * @see PolygonGeometry#createGeometry\r\n */\r\nPolygonGeometry.fromPositions = function (options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"options.positions\", options.positions);\r\n  //>>includeEnd('debug');\r\n\r\n  const newOptions = {\r\n    polygonHierarchy: {\r\n      positions: options.positions,\r\n    },\r\n    height: options.height,\r\n    extrudedHeight: options.extrudedHeight,\r\n    vertexFormat: options.vertexFormat,\r\n    stRotation: options.stRotation,\r\n    ellipsoid: options.ellipsoid,\r\n    granularity: options.granularity,\r\n    perPositionHeight: options.perPositionHeight,\r\n    closeTop: options.closeTop,\r\n    closeBottom: options.closeBottom,\r\n    offsetAttribute: options.offsetAttribute,\r\n    arcType: options.arcType,\r\n    textureCoordinates: options.textureCoordinates,\r\n  };\r\n  return new PolygonGeometry(newOptions);\r\n};\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nPolygonGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n    value._polygonHierarchy,\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._height;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._stRotation;\r\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\r\n  array[startingIndex++] = value._arcType;\r\n  if (defined(value._textureCoordinates)) {\r\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n      value._textureCoordinates,\r\n      array,\r\n      startingIndex,\r\n      Cartesian2\r\n    );\r\n  } else {\r\n    array[startingIndex++] = -1.0;\r\n  }\r\n  array[startingIndex++] = value.packedLength;\r\n  return array;\r\n};\r\n\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst scratchVertexFormat = new VertexFormat();\r\n\r\n//Only used to avoid inability to default construct.\r\nconst dummyOptions = {\r\n  polygonHierarchy: {},\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonGeometry} [result] The object into which to store the result.\r\n */\r\nPolygonGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n  startingIndex = polygonHierarchy.startingIndex;\r\n  delete polygonHierarchy.startingIndex;\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  const height = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const granularity = array[startingIndex++];\r\n  const stRotation = array[startingIndex++];\r\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\r\n  const perPositionHeight = array[startingIndex++] === 1.0;\r\n  const closeTop = array[startingIndex++] === 1.0;\r\n  const closeBottom = array[startingIndex++] === 1.0;\r\n  const shadowVolume = array[startingIndex++] === 1.0;\r\n  const offsetAttribute = array[startingIndex++];\r\n  const arcType = array[startingIndex++];\r\n  const textureCoordinates =\r\n    array[startingIndex] === -1.0\r\n      ? undefined\r\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n          array,\r\n          startingIndex,\r\n          Cartesian2\r\n        );\r\n  if (defined(textureCoordinates)) {\r\n    startingIndex = textureCoordinates.startingIndex;\r\n    delete textureCoordinates.startingIndex;\r\n  } else {\r\n    startingIndex++;\r\n  }\r\n  const packedLength = array[startingIndex++];\r\n\r\n  if (!defined(result)) {\r\n    result = new PolygonGeometry(dummyOptions);\r\n  }\r\n\r\n  result._polygonHierarchy = polygonHierarchy;\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._height = height;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._granularity = granularity;\r\n  result._stRotation = stRotation;\r\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  result._perPositionHeight = perPositionHeight;\r\n  result._closeTop = closeTop;\r\n  result._closeBottom = closeBottom;\r\n  result._shadowVolume = shadowVolume;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n  result._arcType = arcType;\r\n  result._textureCoordinates = textureCoordinates;\r\n  result.packedLength = packedLength;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns the bounding rectangle given the provided options\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Rectangle} [result] An object in which to store the result.\r\n *\r\n * @returns {Rectangle} The result rectangle\r\n */\r\nPolygonGeometry.computeRectangle = function (options, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n  //>>includeEnd('debug');\r\n\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n  return computeRectangle(\r\n    polygonHierarchy.positions,\r\n    ellipsoid,\r\n    arcType,\r\n    granularity,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nPolygonGeometry.createGeometry = function (polygonGeometry) {\r\n  const vertexFormat = polygonGeometry._vertexFormat;\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const granularity = polygonGeometry._granularity;\r\n  const stRotation = polygonGeometry._stRotation;\r\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\r\n  const perPositionHeight = polygonGeometry._perPositionHeight;\r\n  const closeTop = polygonGeometry._closeTop;\r\n  const closeBottom = polygonGeometry._closeBottom;\r\n  const arcType = polygonGeometry._arcType;\r\n  const textureCoordinates = polygonGeometry._textureCoordinates;\r\n\r\n  const hasTextureCoordinates = defined(textureCoordinates);\r\n\r\n  let outerPositions = polygonHierarchy.positions;\r\n  if (outerPositions.length < 3) {\r\n    return;\r\n  }\r\n\r\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(\r\n    outerPositions,\r\n    ellipsoid\r\n  );\r\n\r\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\r\n    polygonHierarchy,\r\n    hasTextureCoordinates,\r\n    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\r\n    !perPositionHeight,\r\n    ellipsoid\r\n  );\r\n\r\n  const hierarchy = results.hierarchy;\r\n  const polygons = results.polygons;\r\n\r\n  const dummyFunction = function (identity) {\r\n    return identity;\r\n  };\r\n\r\n  const textureCoordinatePolygons = hasTextureCoordinates\r\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\r\n        textureCoordinates,\r\n        true,\r\n        dummyFunction,\r\n        false\r\n      ).polygons\r\n    : undefined;\r\n\r\n  if (hierarchy.length === 0) {\r\n    return;\r\n  }\r\n\r\n  outerPositions = hierarchy[0].outerRing;\r\n  const boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\r\n    tangentPlane.plane.normal,\r\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\r\n    outerPositions,\r\n    stRotation,\r\n    scratchBoundingRectangle\r\n  );\r\n\r\n  const geometries = [];\r\n\r\n  const height = polygonGeometry._height;\r\n  const extrudedHeight = polygonGeometry._extrudedHeight;\r\n  const extrude =\r\n    polygonGeometry._perPositionHeightExtrude ||\r\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n  const options = {\r\n    perPositionHeight: perPositionHeight,\r\n    vertexFormat: vertexFormat,\r\n    geometry: undefined,\r\n    tangentPlane: tangentPlane,\r\n    boundingRectangle: boundingRectangle,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: stRotation,\r\n    textureCoordinates: undefined,\r\n    bottom: false,\r\n    top: true,\r\n    wall: false,\r\n    extrude: false,\r\n    arcType: arcType,\r\n  };\r\n\r\n  let i;\r\n\r\n  if (extrude) {\r\n    options.extrude = true;\r\n    options.top = closeTop;\r\n    options.bottom = closeBottom;\r\n    options.shadowVolume = polygonGeometry._shadowVolume;\r\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\r\n    for (i = 0; i < polygons.length; i++) {\r\n      const splitGeometry = createGeometryFromPositionsExtruded(\r\n        ellipsoid,\r\n        polygons[i],\r\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\r\n        granularity,\r\n        hierarchy[i],\r\n        perPositionHeight,\r\n        closeTop,\r\n        closeBottom,\r\n        vertexFormat,\r\n        arcType\r\n      );\r\n\r\n      let topAndBottom;\r\n      if (closeTop && closeBottom) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n          topAndBottom.geometry,\r\n          height,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          perPositionHeight\r\n        );\r\n      } else if (closeTop) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n          topAndBottom.geometry.attributes.position.values,\r\n          height,\r\n          ellipsoid,\r\n          !perPositionHeight\r\n        );\r\n        options.geometry = topAndBottom.geometry;\r\n      } else if (closeBottom) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n          topAndBottom.geometry.attributes.position.values,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          true\r\n        );\r\n        options.geometry = topAndBottom.geometry;\r\n      }\r\n      if (closeTop || closeBottom) {\r\n        options.wall = false;\r\n        topAndBottom.geometry = computeAttributes(options);\r\n        geometries.push(topAndBottom);\r\n      }\r\n\r\n      const walls = splitGeometry.walls;\r\n      options.wall = true;\r\n      for (let k = 0; k < walls.length; k++) {\r\n        const wall = walls[k];\r\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n          wall.geometry,\r\n          height,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          perPositionHeight\r\n        );\r\n        wall.geometry = computeAttributes(options);\r\n        geometries.push(wall);\r\n      }\r\n    }\r\n  } else {\r\n    for (i = 0; i < polygons.length; i++) {\r\n      const geometryInstance = new GeometryInstance({\r\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\r\n          ellipsoid,\r\n          polygons[i],\r\n          hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\r\n          granularity,\r\n          perPositionHeight,\r\n          vertexFormat,\r\n          arcType\r\n        ),\r\n      });\r\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n        geometryInstance.geometry.attributes.position.values,\r\n        height,\r\n        ellipsoid,\r\n        !perPositionHeight\r\n      );\r\n      options.geometry = geometryInstance.geometry;\r\n\r\n      geometryInstance.geometry = computeAttributes(options);\r\n\r\n      if (defined(polygonGeometry._offsetAttribute)) {\r\n        const length =\r\n          geometryInstance.geometry.attributes.position.values.length;\r\n        const offsetValue =\r\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n            ? 0\r\n            : 1;\r\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\r\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\r\n          {\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: applyOffset,\r\n          }\r\n        );\r\n      }\r\n\r\n      geometries.push(geometryInstance);\r\n    }\r\n  }\r\n\r\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\r\n  geometry.attributes.position.values = new Float64Array(\r\n    geometry.attributes.position.values\r\n  );\r\n  geometry.indices = IndexDatatype.createTypedArray(\r\n    geometry.attributes.position.values.length / 3,\r\n    geometry.indices\r\n  );\r\n\r\n  const attributes = geometry.attributes;\r\n  const boundingSphere = BoundingSphere.fromVertices(\r\n    attributes.position.values\r\n  );\r\n\r\n  if (!vertexFormat.position) {\r\n    delete attributes.position;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: geometry.primitiveType,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: polygonGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPolygonGeometry.createShadowVolume = function (\r\n  polygonGeometry,\r\n  minHeightFunc,\r\n  maxHeightFunc\r\n) {\r\n  const granularity = polygonGeometry._granularity;\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n\r\n  const minHeight = minHeightFunc(granularity, ellipsoid);\r\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n  return new PolygonGeometry({\r\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: polygonGeometry._stRotation,\r\n    granularity: granularity,\r\n    perPositionHeight: false,\r\n    extrudedHeight: minHeight,\r\n    height: maxHeight,\r\n    vertexFormat: VertexFormat.POSITION_ONLY,\r\n    shadowVolume: true,\r\n    arcType: polygonGeometry._arcType,\r\n  });\r\n};\r\n\r\nfunction textureCoordinateRotationPoints(polygonGeometry) {\r\n  const stRotation = -polygonGeometry._stRotation;\r\n  if (stRotation === 0.0) {\r\n    return [0, 0, 0, 1, 1, 0];\r\n  }\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const positions = polygonGeometry._polygonHierarchy.positions;\r\n  const boundingRectangle = polygonGeometry.rectangle;\r\n  return Geometry._textureCoordinateRotationPoints(\r\n    positions,\r\n    stRotation,\r\n    ellipsoid,\r\n    boundingRectangle\r\n  );\r\n}\r\n\r\nObject.defineProperties(PolygonGeometry.prototype, {\r\n  /**\r\n   * @private\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      if (!defined(this._rectangle)) {\r\n        const positions = this._polygonHierarchy.positions;\r\n        this._rectangle = computeRectangle(\r\n          positions,\r\n          this._ellipsoid,\r\n          this._arcType,\r\n          this._granularity\r\n        );\r\n      }\r\n\r\n      return this._rectangle;\r\n    },\r\n  },\r\n  /**\r\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\r\n   * @private\r\n   */\r\n  textureCoordinateRotationPoints: {\r\n    get: function () {\r\n      if (!defined(this._textureCoordinateRotationPoints)) {\r\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\r\n          this\r\n        );\r\n      }\r\n      return this._textureCoordinateRotationPoints;\r\n    },\r\n  },\r\n});\r\nexport default PolygonGeometry;\r\n","import defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\r\n\r\nfunction createPolygonGeometry(polygonGeometry, offset) {\r\n  if (defined(offset)) {\r\n    polygonGeometry = PolygonGeometry.unpack(polygonGeometry, offset);\r\n  }\r\n  polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);\r\n  return PolygonGeometry.createGeometry(polygonGeometry);\r\n}\r\nexport default createPolygonGeometry;\r\n"],"names":["scratchCarto1","Cartographic","scratchCarto2","adjustPosHeightsForNormal","position","p1","p2","ellipsoid","height","cartesianToCartographic","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","BoundingRectangle","scratchPosition","Cartesian3","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","Cartesian2","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","Quaternion","appendTextureCoordinatesMatrix3","Matrix3","tangentMatrixScratch","computeAttributes","options","vertexFormat","geometry","shadowVolume","flatPositions","attributes","values","flatTexcoords","defined","st","undefined","length","wall","top","bottom","normal","tangent","bitangent","boundingRectangle","tangentPlane","stRotation","perPositionHeight","origin","x","y","textureCoordinates","Float32Array","normals","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","fromAxisAngle","_plane","fromQuaternion","clone","IDENTITY","bottomOffset","bottomOffset2","i","fromArray","p","multiplyByVector","scaleToGeodeticSurface","projectPointOntoPlane","subtract","stx","CesiumMath","clamp","width","sty","attrIndex1","attrIndex2","normalize","cross","equalsEpsilon","EPSILON10","geodeticSurfaceNormal","UNIT_Z","z","GeometryAttribute","componentDatatype","ComponentDatatype","FLOAT","componentsPerAttribute","extrudeDirection","extrude","offsetAttribute","size","Uint8Array","GeometryOffsetAttribute","TOP","fill","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","EllipsoidGeodesic","computeRectangle","positions","arcType","granularity","result","defaultValue","Rectangle","west","north","south","east","ArcType","RHUMB","fromCartesianArray","equals","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","inverseChordLength","chordLength","maximumRadius","positionsLength","swap","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","PI","TWO_PI","interpolatedCartographicScratch","segmentLength","surfaceDistance","numPoints","Math","ceil","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","longitude","latitude","min","max","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","hierarchy","closeTop","closeBottom","geos","walls","topGeo","PolygonGeometryLibrary","createGeometryFromPositions","edgePoints","indices","numPositions","newIndices","topBottomPositions","concat","IndexDatatype","createTypedArray","set","ilength","i0","i1","i2","texcoords","topAndBottom","GeometryInstance","outerRing","EllipsoidTangentPlane","fromPoints","positions2D","projectPointsOntoPlane","windingOrder","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","slice","reverse","wallGeo","computeWallGeometry","push","holes","hole","COUNTER_CLOCKWISE","PolygonGeometry","Check","typeOf","object","polygonHierarchy","DeveloperError","GEODESIC","VertexFormat","DEFAULT","Ellipsoid","WGS84","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","this","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","_textureCoordinates","packedLength","computeHierarchyPackedLength","fromPositions","EMPTY_OBJECT","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","dummyOptions","unpack","unpackPolygonHierarchy","createGeometry","polygonGeometry","hasTextureCoordinates","outerPositions","results","polygonsFromHierarchy","bind","polygons","textureCoordinatePolygons","identity","computeBoundingRectangle","plane","geometries","EPSILON2","splitGeometry","scaleToGeodeticHeightExtruded","scaleToGeodeticHeight","k","geometryInstance","GeometryPipeline","combineInstances","Float64Array","boundingSphere","BoundingSphere","fromVertices","Geometry","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","rectangle","get","textureCoordinateRotationPoints","offset"],"mappings":"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"}