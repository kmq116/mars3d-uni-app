{"version":3,"file":"createPolygonOutlineGeometry.js","sources":["../../../../Source/Core/PolygonOutlineGeometry.js","../../../../Source/WorkersES6/createPolygonOutlineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryInstance from \"./GeometryInstance.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport GeometryPipeline from \"./GeometryPipeline.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport WindingOrder from \"./WindingOrder.js\";\r\nconst createGeometryFromPositionsPositions = [];\r\nconst createGeometryFromPositionsSubdivided = [];\r\n\r\nfunction createGeometryFromPositions(\r\n  ellipsoid,\r\n  positions,\r\n  minDistance,\r\n  perPositionHeight,\r\n  arcType\r\n) {\r\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\r\n  const positions2D = tangentPlane.projectPointsOntoPlane(\r\n    positions,\r\n    createGeometryFromPositionsPositions\r\n  );\r\n\r\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\r\n    positions2D\r\n  );\r\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n    positions2D.reverse();\r\n    positions = positions.slice().reverse();\r\n  }\r\n\r\n  let subdividedPositions;\r\n  let i;\r\n\r\n  let length = positions.length;\r\n  let index = 0;\r\n\r\n  if (!perPositionHeight) {\r\n    let numVertices = 0;\r\n    if (arcType === ArcType.GEODESIC) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    } else if (arcType === ArcType.RHUMB) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\r\n          ellipsoid,\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    }\r\n    subdividedPositions = new Float64Array(numVertices * 3);\r\n    for (i = 0; i < length; i++) {\r\n      let tempPositions;\r\n      if (arcType === ArcType.GEODESIC) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance,\r\n          createGeometryFromPositionsSubdivided\r\n        );\r\n      } else if (arcType === ArcType.RHUMB) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\r\n          ellipsoid,\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance,\r\n          createGeometryFromPositionsSubdivided\r\n        );\r\n      }\r\n      const tempPositionsLength = tempPositions.length;\r\n      for (let j = 0; j < tempPositionsLength; ++j) {\r\n        subdividedPositions[index++] = tempPositions[j];\r\n      }\r\n    }\r\n  } else {\r\n    subdividedPositions = new Float64Array(length * 2 * 3);\r\n    for (i = 0; i < length; i++) {\r\n      const p0 = positions[i];\r\n      const p1 = positions[(i + 1) % length];\r\n      subdividedPositions[index++] = p0.x;\r\n      subdividedPositions[index++] = p0.y;\r\n      subdividedPositions[index++] = p0.z;\r\n      subdividedPositions[index++] = p1.x;\r\n      subdividedPositions[index++] = p1.y;\r\n      subdividedPositions[index++] = p1.z;\r\n    }\r\n  }\r\n\r\n  length = subdividedPositions.length / 3;\r\n  const indicesSize = length * 2;\r\n  const indices = IndexDatatype.createTypedArray(length, indicesSize);\r\n  index = 0;\r\n  for (i = 0; i < length - 1; i++) {\r\n    indices[index++] = i;\r\n    indices[index++] = i + 1;\r\n  }\r\n  indices[index++] = length - 1;\r\n  indices[index++] = 0;\r\n\r\n  return new GeometryInstance({\r\n    geometry: new Geometry({\r\n      attributes: new GeometryAttributes({\r\n        position: new GeometryAttribute({\r\n          componentDatatype: ComponentDatatype.DOUBLE,\r\n          componentsPerAttribute: 3,\r\n          values: subdividedPositions,\r\n        }),\r\n      }),\r\n      indices: indices,\r\n      primitiveType: PrimitiveType.LINES,\r\n    }),\r\n  });\r\n}\r\n\r\nfunction createGeometryFromPositionsExtruded(\r\n  ellipsoid,\r\n  positions,\r\n  minDistance,\r\n  perPositionHeight,\r\n  arcType\r\n) {\r\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\r\n  const positions2D = tangentPlane.projectPointsOntoPlane(\r\n    positions,\r\n    createGeometryFromPositionsPositions\r\n  );\r\n\r\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\r\n    positions2D\r\n  );\r\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n    positions2D.reverse();\r\n    positions = positions.slice().reverse();\r\n  }\r\n\r\n  let subdividedPositions;\r\n  let i;\r\n\r\n  let length = positions.length;\r\n  const corners = new Array(length);\r\n  let index = 0;\r\n\r\n  if (!perPositionHeight) {\r\n    let numVertices = 0;\r\n    if (arcType === ArcType.GEODESIC) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    } else if (arcType === ArcType.RHUMB) {\r\n      for (i = 0; i < length; i++) {\r\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\r\n          ellipsoid,\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance\r\n        );\r\n      }\r\n    }\r\n\r\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\r\n    for (i = 0; i < length; ++i) {\r\n      corners[i] = index / 3;\r\n      let tempPositions;\r\n      if (arcType === ArcType.GEODESIC) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance,\r\n          createGeometryFromPositionsSubdivided\r\n        );\r\n      } else if (arcType === ArcType.RHUMB) {\r\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\r\n          ellipsoid,\r\n          positions[i],\r\n          positions[(i + 1) % length],\r\n          minDistance,\r\n          createGeometryFromPositionsSubdivided\r\n        );\r\n      }\r\n      const tempPositionsLength = tempPositions.length;\r\n      for (let j = 0; j < tempPositionsLength; ++j) {\r\n        subdividedPositions[index++] = tempPositions[j];\r\n      }\r\n    }\r\n  } else {\r\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\r\n    for (i = 0; i < length; ++i) {\r\n      corners[i] = index / 3;\r\n      const p0 = positions[i];\r\n      const p1 = positions[(i + 1) % length];\r\n\r\n      subdividedPositions[index++] = p0.x;\r\n      subdividedPositions[index++] = p0.y;\r\n      subdividedPositions[index++] = p0.z;\r\n      subdividedPositions[index++] = p1.x;\r\n      subdividedPositions[index++] = p1.y;\r\n      subdividedPositions[index++] = p1.z;\r\n    }\r\n  }\r\n\r\n  length = subdividedPositions.length / (3 * 2);\r\n  const cornersLength = corners.length;\r\n\r\n  const indicesSize = (length * 2 + cornersLength) * 2;\r\n  const indices = IndexDatatype.createTypedArray(\r\n    length + cornersLength,\r\n    indicesSize\r\n  );\r\n\r\n  index = 0;\r\n  for (i = 0; i < length; ++i) {\r\n    indices[index++] = i;\r\n    indices[index++] = (i + 1) % length;\r\n    indices[index++] = i + length;\r\n    indices[index++] = ((i + 1) % length) + length;\r\n  }\r\n\r\n  for (i = 0; i < cornersLength; i++) {\r\n    const corner = corners[i];\r\n    indices[index++] = corner;\r\n    indices[index++] = corner + length;\r\n  }\r\n\r\n  return new GeometryInstance({\r\n    geometry: new Geometry({\r\n      attributes: new GeometryAttributes({\r\n        position: new GeometryAttribute({\r\n          componentDatatype: ComponentDatatype.DOUBLE,\r\n          componentsPerAttribute: 3,\r\n          values: subdividedPositions,\r\n        }),\r\n      }),\r\n      indices: indices,\r\n      primitiveType: PrimitiveType.LINES,\r\n    }),\r\n  });\r\n}\r\n\r\n/**\r\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\r\n *\r\n * @alias PolygonOutlineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n *\r\n * @see PolygonOutlineGeometry#createGeometry\r\n * @see PolygonOutlineGeometry#fromPositions\r\n *\r\n * @example\r\n * // 1. create a polygon outline from points\r\n * const polygon = new Cesium.PolygonOutlineGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\r\n *\r\n * // 2. create a nested polygon with holes outline\r\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -109.0, 30.0,\r\n *       -95.0, 30.0,\r\n *       -95.0, 40.0,\r\n *       -109.0, 40.0\r\n *     ]),\r\n *     [new Cesium.PolygonHierarchy(\r\n *       Cesium.Cartesian3.fromDegreesArray([\r\n *         -107.0, 31.0,\r\n *         -107.0, 39.0,\r\n *         -97.0, 39.0,\r\n *         -97.0, 31.0\r\n *       ]),\r\n *       [new Cesium.PolygonHierarchy(\r\n *         Cesium.Cartesian3.fromDegreesArray([\r\n *           -105.0, 33.0,\r\n *           -99.0, 33.0,\r\n *           -99.0, 37.0,\r\n *           -105.0, 37.0\r\n *         ]),\r\n *         [new Cesium.PolygonHierarchy(\r\n *           Cesium.Cartesian3.fromDegreesArray([\r\n *             -103.0, 34.0,\r\n *             -101.0, 34.0,\r\n *             -101.0, 36.0,\r\n *             -103.0, 36.0\r\n *           ])\r\n *         )]\r\n *       )]\r\n *     )]\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\r\n *\r\n * // 3. create extruded polygon outline\r\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   ),\r\n *   extrudedHeight: 300000\r\n * });\r\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\r\n */\r\nfunction PolygonOutlineGeometry(options) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n\r\n  if (options.perPositionHeight && defined(options.height)) {\r\n    throw new DeveloperError(\r\n      \"Cannot use both options.perPositionHeight and options.height\"\r\n    );\r\n  }\r\n  if (\r\n    defined(options.arcType) &&\r\n    options.arcType !== ArcType.GEODESIC &&\r\n    options.arcType !== ArcType.RHUMB\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\r\n  const perPositionHeightExtrude =\r\n    perPositionHeight && defined(options.extrudedHeight);\r\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n  let height = defaultValue(options.height, 0.0);\r\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  if (!perPositionHeightExtrude) {\r\n    const h = Math.max(height, extrudedHeight);\r\n    extrudedHeight = Math.min(height, extrudedHeight);\r\n    height = h;\r\n  }\r\n\r\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n  this._granularity = granularity;\r\n  this._height = height;\r\n  this._extrudedHeight = extrudedHeight;\r\n  this._arcType = arcType;\r\n  this._polygonHierarchy = polygonHierarchy;\r\n  this._perPositionHeight = perPositionHeight;\r\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._workerName = \"createPolygonOutlineGeometry\";\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n      polygonHierarchy,\r\n      Cartesian3\r\n    ) +\r\n    Ellipsoid.packedLength +\r\n    8;\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonOutlineGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n    value._polygonHierarchy,\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  array[startingIndex++] = value._height;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._arcType;\r\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\r\n  array[startingIndex] = value.packedLength;\r\n\r\n  return array;\r\n};\r\n\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst dummyOptions = {\r\n  polygonHierarchy: {},\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\r\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\r\n */\r\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n  startingIndex = polygonHierarchy.startingIndex;\r\n  delete polygonHierarchy.startingIndex;\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const height = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const granularity = array[startingIndex++];\r\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\r\n  const perPositionHeight = array[startingIndex++] === 1.0;\r\n  const arcType = array[startingIndex++];\r\n  const offsetAttribute = array[startingIndex++];\r\n  const packedLength = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    result = new PolygonOutlineGeometry(dummyOptions);\r\n  }\r\n\r\n  result._polygonHierarchy = polygonHierarchy;\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._height = height;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._granularity = granularity;\r\n  result._perPositionHeight = perPositionHeight;\r\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  result._arcType = arcType;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n  result.packedLength = packedLength;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * A description of a polygon outline from an array of positions.\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\r\n * @param {Number} [options.height=0.0] The height of the polygon.\r\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @returns {PolygonOutlineGeometry}\r\n *\r\n *\r\n * @example\r\n * // create a polygon from points\r\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\r\n *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n *     -72.0, 40.0,\r\n *     -70.0, 35.0,\r\n *     -75.0, 30.0,\r\n *     -70.0, 30.0,\r\n *     -68.0, 40.0\r\n *   ])\r\n * });\r\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\r\n *\r\n * @see PolygonOutlineGeometry#createGeometry\r\n */\r\nPolygonOutlineGeometry.fromPositions = function (options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"options.positions\", options.positions);\r\n  //>>includeEnd('debug');\r\n\r\n  const newOptions = {\r\n    polygonHierarchy: {\r\n      positions: options.positions,\r\n    },\r\n    height: options.height,\r\n    extrudedHeight: options.extrudedHeight,\r\n    ellipsoid: options.ellipsoid,\r\n    granularity: options.granularity,\r\n    perPositionHeight: options.perPositionHeight,\r\n    arcType: options.arcType,\r\n    offsetAttribute: options.offsetAttribute,\r\n  };\r\n  return new PolygonOutlineGeometry(newOptions);\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const granularity = polygonGeometry._granularity;\r\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\r\n  const perPositionHeight = polygonGeometry._perPositionHeight;\r\n  const arcType = polygonGeometry._arcType;\r\n\r\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\r\n    polygonHierarchy,\r\n    !perPositionHeight,\r\n    ellipsoid\r\n  );\r\n\r\n  if (polygons.length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  let geometryInstance;\r\n  const geometries = [];\r\n  const minDistance = CesiumMath.chordLength(\r\n    granularity,\r\n    ellipsoid.maximumRadius\r\n  );\r\n\r\n  const height = polygonGeometry._height;\r\n  const extrudedHeight = polygonGeometry._extrudedHeight;\r\n  const extrude =\r\n    polygonGeometry._perPositionHeightExtrude ||\r\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n  let offsetValue;\r\n  let i;\r\n  if (extrude) {\r\n    for (i = 0; i < polygons.length; i++) {\r\n      geometryInstance = createGeometryFromPositionsExtruded(\r\n        ellipsoid,\r\n        polygons[i],\r\n        minDistance,\r\n        perPositionHeight,\r\n        arcType\r\n      );\r\n      geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n        geometryInstance.geometry,\r\n        height,\r\n        extrudedHeight,\r\n        ellipsoid,\r\n        perPositionHeight\r\n      );\r\n      if (defined(polygonGeometry._offsetAttribute)) {\r\n        const size =\r\n          geometryInstance.geometry.attributes.position.values.length / 3;\r\n        let offsetAttribute = new Uint8Array(size);\r\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n          offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\r\n        } else {\r\n          offsetValue =\r\n            polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n              ? 0\r\n              : 1;\r\n          offsetAttribute = offsetAttribute.fill(offsetValue);\r\n        }\r\n\r\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\r\n          {\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: offsetAttribute,\r\n          }\r\n        );\r\n      }\r\n      geometries.push(geometryInstance);\r\n    }\r\n  } else {\r\n    for (i = 0; i < polygons.length; i++) {\r\n      geometryInstance = createGeometryFromPositions(\r\n        ellipsoid,\r\n        polygons[i],\r\n        minDistance,\r\n        perPositionHeight,\r\n        arcType\r\n      );\r\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n        geometryInstance.geometry.attributes.position.values,\r\n        height,\r\n        ellipsoid,\r\n        !perPositionHeight\r\n      );\r\n\r\n      if (defined(polygonGeometry._offsetAttribute)) {\r\n        const length =\r\n          geometryInstance.geometry.attributes.position.values.length;\r\n        offsetValue =\r\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n            ? 0\r\n            : 1;\r\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\r\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\r\n          {\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: applyOffset,\r\n          }\r\n        );\r\n      }\r\n\r\n      geometries.push(geometryInstance);\r\n    }\r\n  }\r\n\r\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\r\n  const boundingSphere = BoundingSphere.fromVertices(\r\n    geometry.attributes.position.values\r\n  );\r\n\r\n  return new Geometry({\r\n    attributes: geometry.attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: geometry.primitiveType,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: polygonGeometry._offsetAttribute,\r\n  });\r\n};\r\nexport default PolygonOutlineGeometry;\r\n","import defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport PolygonOutlineGeometry from \"../Core/PolygonOutlineGeometry.js\";\r\n\r\nfunction createPolygonOutlineGeometry(polygonGeometry, offset) {\r\n  if (defined(offset)) {\r\n    polygonGeometry = PolygonOutlineGeometry.unpack(polygonGeometry, offset);\r\n  }\r\n  polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);\r\n  return PolygonOutlineGeometry.createGeometry(polygonGeometry);\r\n}\r\nexport default createPolygonOutlineGeometry;\r\n"],"names":["createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","createGeometryFromPositions","ellipsoid","positions","minDistance","perPositionHeight","arcType","positions2D","EllipsoidTangentPlane","fromPoints","projectPointsOntoPlane","subdividedPositions","i","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","slice","length","index","Float64Array","p0","p1","x","y","z","numVertices","ArcType","GEODESIC","PolygonGeometryLibrary","subdivideLineCount","RHUMB","subdivideRhumbLineCount","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","j","indicesSize","indices","IndexDatatype","createTypedArray","GeometryInstance","geometry","Geometry","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","PrimitiveType","LINES","createGeometryFromPositionsExtruded","corners","Array","cornersLength","corner","PolygonOutlineGeometry","options","Check","typeOf","object","polygonHierarchy","defined","height","DeveloperError","defaultValue","Ellipsoid","WGS84","granularity","CesiumMath","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","this","_ellipsoid","clone","_granularity","_height","_extrudedHeight","_arcType","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_offsetAttribute","offsetAttribute","_workerName","packedLength","computeHierarchyPackedLength","Cartesian3","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","dummyOptions","unpack","result","unpackPolygonHierarchy","undefined","fromPositions","EMPTY_OBJECT","createGeometry","polygonGeometry","polygons","polygonOutlinesFromHierarchy","geometryInstance","geometries","chordLength","maximumRadius","offsetValue","equalsEpsilon","EPSILON2","scaleToGeodeticHeightExtruded","size","Uint8Array","GeometryOffsetAttribute","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","push","scaleToGeodeticHeight","GeometryPipeline","combineInstances","boundingSphere","BoundingSphere","fromVertices","offset"],"mappings":"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"}