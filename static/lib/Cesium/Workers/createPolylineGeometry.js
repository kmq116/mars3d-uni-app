/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-ac2201bb","./Matrix2-5bde29de","./ArcType-5c683766","./arrayRemoveDuplicates-68f14b2f","./Transforms-3f580a0c","./Color-88e452bd","./ComponentDatatype-164c57e1","./RuntimeError-d45af186","./GeometryAttribute-f83e6129","./GeometryAttributes-d060f8b5","./IndexDatatype-4e1ec1a1","./PolylinePipeline-01f0ccf8","./VertexFormat-4a6cdfad","./_commonjsHelpers-3aae1032-ac53d93e","./combine-0dce9b0f","./WebGLConstants-e12cdc8a","./EllipsoidGeodesic-dedaf218","./EllipsoidRhumbLine-bfb4fa95","./IntersectionTests-0d91a773","./Plane-3ad20be7"],(function(e,t,o,r,n,a,i,l,s,c,p,d,u,f,y,m,h,C,g,w){"use strict";const E=[];function _(e,t,o,r,n){const i=E;let l;i.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,f=r.green,y=r.blue,m=r.alpha;if(a.Color.equals(o,r)){for(l=0;l<n;l++)i[l]=a.Color.clone(o);return i}const h=(u-s)/n,C=(f-c)/n,g=(y-p)/n,w=(m-d)/n;for(l=0;l<n;l++)i[l]=new a.Color(s+l*h,c+l*C,p+l*g,d+l*w);return i}function b(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,s=r.colors,c=e.defaultValue(r.width,1),p=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(n)||n.length<2)throw new l.DeveloperError("At least two positions are required.");if("number"!=typeof c)throw new l.DeveloperError("width must be a number");if(e.defined(s)&&(p&&s.length<n.length||!p&&s.length<n.length-1))throw new l.DeveloperError("colors has an invalid length.");this._positions=n,this._colors=s,this._width=c,this._colorsPerVertex=p,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(r.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,i.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let d=1+n.length*t.Cartesian3.packedLength;d+=e.defined(s)?1+s.length*a.Color.packedLength:1,this.packedLength=d+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}b.pack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("value is required");if(!e.defined(r))throw new l.DeveloperError("array is required");let i;n=e.defaultValue(n,0);const s=o._positions;let c=s.length;for(r[n++]=c,i=0;i<c;++i,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[i],r,n);const p=o._colors;for(c=e.defined(p)?p.length:0,r[n++]=c,i=0;i<c;++i,n+=a.Color.packedLength)a.Color.pack(p[i],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,u.VertexFormat.pack(o._vertexFormat,r,n),n+=u.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const A=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),P=new u.VertexFormat,v={positions:void 0,colors:void 0,ellipsoid:A,vertexFormat:P,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};b.unpack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("array is required");let i;r=e.defaultValue(r,0);let s=o[r++];const c=new Array(s);for(i=0;i<s;++i,r+=t.Cartesian3.packedLength)c[i]=t.Cartesian3.unpack(o,r);s=o[r++];const p=s>0?new Array(s):void 0;for(i=0;i<s;++i,r+=a.Color.packedLength)p[i]=a.Color.unpack(o,r);const d=t.Ellipsoid.unpack(o,r,A);r+=t.Ellipsoid.packedLength;const f=u.VertexFormat.unpack(o,r,P);r+=u.VertexFormat.packedLength;const y=o[r++],m=1===o[r++],h=o[r++],C=o[r];return e.defined(n)?(n._positions=c,n._colors=p,n._ellipsoid=t.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=u.VertexFormat.clone(f,n._vertexFormat),n._width=y,n._colorsPerVertex=m,n._arcType=h,n._granularity=C,n):(v.positions=c,v.colors=p,v.width=y,v.colorsPerVertex=m,v.arcType=h,v.granularity=C,new b(v))};const D=new t.Cartesian3,x=new t.Cartesian3,T=new t.Cartesian3,k=new t.Cartesian3;return b.createGeometry=function(l){const u=l._width,f=l._vertexFormat;let y=l._colors;const m=l._colorsPerVertex,h=l._arcType,C=l._granularity,g=l._ellipsoid;let w,b,A;const P=[];let v=r.arrayRemoveDuplicates(l._positions,t.Cartesian3.equalsEpsilon,!1,P);if(e.defined(y)&&P.length>0){let e=0,t=P[0];y=y.filter((function(o,r){let n=!1;return n=m?r===t||0===r&&1===t:r+1===t,!n||(e++,t=P[e],!1)}))}let V=v.length;if(V<2||u<=0)return;if(h===o.ArcType.GEODESIC||h===o.ArcType.RHUMB){let t,r;h===o.ArcType.GEODESIC?(t=i.CesiumMath.chordLength(C,g.maximumRadius),r=d.PolylinePipeline.numberOfPoints):(t=C,r=d.PolylinePipeline.numberOfPointsRhumbLine);const n=d.PolylinePipeline.extractHeights(v,g);if(e.defined(y)){let e=1;for(w=0;w<V-1;++w)e+=r(v[w],v[w+1],t);const o=new Array(e);let n=0;for(w=0;w<V-1;++w){const i=v[w],l=v[w+1],s=y[w],c=r(i,l,t);if(m&&w<e){const e=_(0,0,s,y[w+1],c),t=e.length;for(b=0;b<t;++b)o[n++]=e[b]}else for(b=0;b<c;++b)o[n++]=a.Color.clone(s)}o[n]=a.Color.clone(y[y.length-1]),y=o,E.length=0}v=h===o.ArcType.GEODESIC?d.PolylinePipeline.generateCartesianArc({positions:v,minDistance:t,ellipsoid:g,height:n}):d.PolylinePipeline.generateCartesianRhumbArc({positions:v,granularity:t,ellipsoid:g,height:n})}V=v.length;const L=4*V-4,F=new Float64Array(3*L),G=new Float64Array(3*L),O=new Float64Array(3*L),R=new Float32Array(2*L),I=f.st?new Float32Array(2*L):void 0,S=e.defined(y)?new Uint8Array(4*L):void 0;let B,U=0,N=0,q=0,M=0;for(b=0;b<V;++b){let o,r;0===b?(B=D,t.Cartesian3.subtract(v[0],v[1],B),t.Cartesian3.add(v[0],B,B)):B=v[b-1],t.Cartesian3.clone(B,T),t.Cartesian3.clone(v[b],x),b===V-1?(B=D,t.Cartesian3.subtract(v[V-1],v[V-2],B),t.Cartesian3.add(v[V-1],B,B)):B=v[b+1],t.Cartesian3.clone(B,k),e.defined(S)&&(o=0===b||m?y[b]:y[b-1],b!==V-1&&(r=y[b]));const n=b===V-1?2:4;for(A=0===b?2:0;A<n;++A){t.Cartesian3.pack(x,F,U),t.Cartesian3.pack(T,G,U),t.Cartesian3.pack(k,O,U),U+=3;const n=A-2<0?-1:1;if(R[N++]=A%2*2-1,R[N++]=n*u,f.st&&(I[q++]=b/(V-1),I[q++]=Math.max(R[N-2],0)),e.defined(S)){const e=A<2?o:r;S[M++]=a.Color.floatToByte(e.red),S[M++]=a.Color.floatToByte(e.green),S[M++]=a.Color.floatToByte(e.blue),S[M++]=a.Color.floatToByte(e.alpha)}}}const H=new c.GeometryAttributes;H.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),H.prevPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),H.nextPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),H.expandAndWidth=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),f.st&&(H.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(H.color=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));const W=p.IndexDatatype.createTypedArray(L,6*V-6);let Y=0,j=0;const z=V-1;for(b=0;b<z;++b)W[j++]=Y,W[j++]=Y+2,W[j++]=Y+1,W[j++]=Y+1,W[j++]=Y+2,W[j++]=Y+3,Y+=4;return new s.Geometry({attributes:H,indices:W,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(v),geometryType:s.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=b.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),b.createGeometry(o)}}));
//# sourceMappingURL=createPolylineGeometry.js.map
