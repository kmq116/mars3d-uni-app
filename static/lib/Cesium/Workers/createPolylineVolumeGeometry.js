/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-ac2201bb","./Matrix2-5bde29de","./arrayRemoveDuplicates-68f14b2f","./BoundingRectangle-fd9a5062","./Transforms-3f580a0c","./ComponentDatatype-164c57e1","./PolylineVolumeGeometryLibrary-22c14de9","./RuntimeError-d45af186","./GeometryAttribute-f83e6129","./GeometryAttributes-d060f8b5","./GeometryPipeline-690feb65","./IndexDatatype-4e1ec1a1","./PolygonPipeline-71d5516a","./VertexFormat-4a6cdfad","./_commonjsHelpers-3aae1032-ac53d93e","./combine-0dce9b0f","./WebGLConstants-e12cdc8a","./EllipsoidTangentPlane-fa2bc0dc","./AxisAlignedBoundingBox-b2f2975e","./IntersectionTests-0d91a773","./Plane-3ad20be7","./PolylinePipeline-01f0ccf8","./EllipsoidGeodesic-dedaf218","./EllipsoidRhumbLine-bfb4fa95","./AttributeCompression-1cfcbb75","./EncodedCartesian3-83872b10"],(function(e,t,n,o,i,r,a,l,s,p,d,c,u,m,y,f,g,h,b,E,P,_,v,k,V,L){"use strict";function w(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,i=n.shapePositions;if(!e.defined(o))throw new l.DeveloperError("options.polylinePositions is required.");if(!e.defined(i))throw new l.DeveloperError("options.shapePositions is required.");this._positions=o,this._shape=i,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,a.CornerType.ROUNDED),this._vertexFormat=m.VertexFormat.clone(e.defaultValue(n.vertexFormat,m.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let s=1+o.length*t.Cartesian3.packedLength;s+=1+i.length*t.Cartesian2.packedLength,this.packedLength=s+t.Ellipsoid.packedLength+m.VertexFormat.packedLength+2}w.pack=function(n,o,i){if(!e.defined(n))throw new l.DeveloperError("value is required");if(!e.defined(o))throw new l.DeveloperError("array is required");let r;i=e.defaultValue(i,0);const a=n._positions;let s=a.length;for(o[i++]=s,r=0;r<s;++r,i+=t.Cartesian3.packedLength)t.Cartesian3.pack(a[r],o,i);const p=n._shape;for(s=p.length,o[i++]=s,r=0;r<s;++r,i+=t.Cartesian2.packedLength)t.Cartesian2.pack(p[r],o,i);return t.Ellipsoid.pack(n._ellipsoid,o,i),i+=t.Ellipsoid.packedLength,m.VertexFormat.pack(n._vertexFormat,o,i),i+=m.VertexFormat.packedLength,o[i++]=n._cornerType,o[i]=n._granularity,o};const x=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),C=new m.VertexFormat,D={polylinePositions:void 0,shapePositions:void 0,ellipsoid:x,vertexFormat:C,cornerType:void 0,granularity:void 0};w.unpack=function(n,o,i){if(!e.defined(n))throw new l.DeveloperError("array is required");let r;o=e.defaultValue(o,0);let a=n[o++];const s=new Array(a);for(r=0;r<a;++r,o+=t.Cartesian3.packedLength)s[r]=t.Cartesian3.unpack(n,o);a=n[o++];const p=new Array(a);for(r=0;r<a;++r,o+=t.Cartesian2.packedLength)p[r]=t.Cartesian2.unpack(n,o);const d=t.Ellipsoid.unpack(n,o,x);o+=t.Ellipsoid.packedLength;const c=m.VertexFormat.unpack(n,o,C);o+=m.VertexFormat.packedLength;const u=n[o++],y=n[o];return e.defined(i)?(i._positions=s,i._shape=p,i._ellipsoid=t.Ellipsoid.clone(d,i._ellipsoid),i._vertexFormat=m.VertexFormat.clone(c,i._vertexFormat),i._cornerType=u,i._granularity=y,i):(D.polylinePositions=s,D.shapePositions=p,D.cornerType=u,D.granularity=y,new w(D))};const F=new o.BoundingRectangle;return w.createGeometry=function(e){const l=e._positions,m=n.arrayRemoveDuplicates(l,t.Cartesian3.equalsEpsilon);let y=e._shape;if(y=a.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(y),m.length<2||y.length<3)return;u.PolygonPipeline.computeWindingOrder2D(y)===u.WindingOrder.CLOCKWISE&&y.reverse();const f=o.BoundingRectangle.fromPoints(y,F);return function(e,t,n,o){const l=new p.GeometryAttributes;o.position&&(l.position=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));const m=t.length,y=e.length/3,f=(y-2*m)/(2*m),g=u.PolygonPipeline.triangulate(t),h=(f-1)*m*6+2*g.length,b=c.IndexDatatype.createTypedArray(y,h);let E,P,_,v,k,V;const L=2*m;let w=0;for(E=0;E<f-1;E++){for(P=0;P<m-1;P++)_=2*P+E*m*2,V=_+L,v=_+1,k=v+L,b[w++]=v,b[w++]=_,b[w++]=k,b[w++]=k,b[w++]=_,b[w++]=V;_=2*m-2+E*m*2,v=_+1,k=v+L,V=_+L,b[w++]=v,b[w++]=_,b[w++]=k,b[w++]=k,b[w++]=_,b[w++]=V}if(o.st||o.tangent||o.bitangent){const e=new Float32Array(2*y),o=1/(f-1),i=1/n.height,a=n.height/2;let p,d,c=0;for(E=0;E<f;E++){for(p=E*o,d=i*(t[0].y+a),e[c++]=p,e[c++]=d,P=1;P<m;P++)d=i*(t[P].y+a),e[c++]=p,e[c++]=d,e[c++]=p,e[c++]=d;d=i*(t[0].y+a),e[c++]=p,e[c++]=d}for(P=0;P<m;P++)p=0,d=i*(t[P].y+a),e[c++]=p,e[c++]=d;for(P=0;P<m;P++)p=(f-1)*o,d=i*(t[P].y+a),e[c++]=p,e[c++]=d;l.st=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const x=y-2*m;for(E=0;E<g.length;E+=3){const e=g[E]+x,t=g[E+1]+x,n=g[E+2]+x;b[w++]=e,b[w++]=t,b[w++]=n,b[w++]=n+m,b[w++]=t+m,b[w++]=e+m}let C=new s.Geometry({attributes:l,indices:b,boundingSphere:i.BoundingSphere.fromVertices(e),primitiveType:s.PrimitiveType.TRIANGLES});if(o.normal&&(C=d.GeometryPipeline.computeNormal(C)),o.tangent||o.bitangent){try{C=d.GeometryPipeline.computeTangentAndBitangent(C)}catch(e){a.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}o.tangent||(C.attributes.tangent=void 0),o.bitangent||(C.attributes.bitangent=void 0),o.st||(C.attributes.st=void 0)}return C}(a.PolylineVolumeGeometryLibrary.computePositions(m,y,f,e,!0),y,f,e._vertexFormat)},function(n,o){return e.defined(o)&&(n=w.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),w.createGeometry(n)}}));
//# sourceMappingURL=createPolylineVolumeGeometry.js.map
