/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-ac2201bb","./Matrix2-5bde29de","./Transforms-3f580a0c","./ComponentDatatype-164c57e1","./RuntimeError-d45af186","./GeometryAttribute-f83e6129","./GeometryAttributes-d060f8b5","./IndexDatatype-4e1ec1a1","./VertexFormat-4a6cdfad","./WallGeometryLibrary-69f92856","./_commonjsHelpers-3aae1032-ac53d93e","./combine-0dce9b0f","./WebGLConstants-e12cdc8a","./arrayRemoveDuplicates-68f14b2f","./PolylinePipeline-01f0ccf8","./EllipsoidGeodesic-dedaf218","./EllipsoidRhumbLine-bfb4fa95","./IntersectionTests-0d91a773","./Plane-3ad20be7"],(function(e,t,i,n,r,a,o,s,l,m,d,p,u,c,f,h,g,y,C){"use strict";const w=new t.Cartesian3,b=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,v=new t.Cartesian3,A=new t.Cartesian3,_=new t.Cartesian3;function F(i){const a=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions,o=i.maximumHeights,s=i.minimumHeights;if(!e.defined(a))throw new r.DeveloperError("options.positions is required.");if(e.defined(o)&&o.length!==a.length)throw new r.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(s)&&s.length!==a.length)throw new r.DeveloperError("options.positions and options.minimumHeights must have the same length.");const m=e.defaultValue(i.vertexFormat,l.VertexFormat.DEFAULT),d=e.defaultValue(i.granularity,n.CesiumMath.RADIANS_PER_DEGREE),p=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84);this._positions=a,this._minimumHeights=s,this._maximumHeights=o,this._vertexFormat=l.VertexFormat.clone(m),this._granularity=d,this._ellipsoid=t.Ellipsoid.clone(p),this._workerName="createWallGeometry";let u=1+a.length*t.Cartesian3.packedLength+2;e.defined(s)&&(u+=s.length),e.defined(o)&&(u+=o.length),this.packedLength=u+t.Ellipsoid.packedLength+l.VertexFormat.packedLength+1}F.pack=function(i,n,a){if(!e.defined(i))throw new r.DeveloperError("value is required");if(!e.defined(n))throw new r.DeveloperError("array is required");let o;a=e.defaultValue(a,0);const s=i._positions;let m=s.length;for(n[a++]=m,o=0;o<m;++o,a+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[o],n,a);const d=i._minimumHeights;if(m=e.defined(d)?d.length:0,n[a++]=m,e.defined(d))for(o=0;o<m;++o)n[a++]=d[o];const p=i._maximumHeights;if(m=e.defined(p)?p.length:0,n[a++]=m,e.defined(p))for(o=0;o<m;++o)n[a++]=p[o];return t.Ellipsoid.pack(i._ellipsoid,n,a),a+=t.Ellipsoid.packedLength,l.VertexFormat.pack(i._vertexFormat,n,a),n[a+=l.VertexFormat.packedLength]=i._granularity,n};const D=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),H=new l.VertexFormat,L={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:D,vertexFormat:H,granularity:void 0};return F.unpack=function(i,n,a){if(!e.defined(i))throw new r.DeveloperError("array is required");let o;n=e.defaultValue(n,0);let s=i[n++];const m=new Array(s);for(o=0;o<s;++o,n+=t.Cartesian3.packedLength)m[o]=t.Cartesian3.unpack(i,n);let d,p;if(s=i[n++],s>0)for(d=new Array(s),o=0;o<s;++o)d[o]=i[n++];if(s=i[n++],s>0)for(p=new Array(s),o=0;o<s;++o)p[o]=i[n++];const u=t.Ellipsoid.unpack(i,n,D);n+=t.Ellipsoid.packedLength;const c=l.VertexFormat.unpack(i,n,H),f=i[n+=l.VertexFormat.packedLength];return e.defined(a)?(a._positions=m,a._minimumHeights=d,a._maximumHeights=p,a._ellipsoid=t.Ellipsoid.clone(u,a._ellipsoid),a._vertexFormat=l.VertexFormat.clone(c,a._vertexFormat),a._granularity=f,a):(L.positions=m,L.minimumHeights=d,L.maximumHeights=p,L.granularity=f,new F(L))},F.fromConstantHeights=function(t){const i=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;if(!e.defined(i))throw new r.DeveloperError("options.positions is required.");let n,a;const o=t.minimumHeight,s=t.maximumHeight,l=e.defined(o),m=e.defined(s);if(l||m){const e=i.length;n=l?new Array(e):void 0,a=m?new Array(e):void 0;for(let t=0;t<e;++t)l&&(n[t]=o),m&&(a[t]=s)}return new F({positions:i,maximumHeights:a,minimumHeights:n,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},F.createGeometry=function(r){const l=r._positions,d=r._minimumHeights,p=r._maximumHeights,u=r._vertexFormat,c=r._granularity,f=r._ellipsoid,h=m.WallGeometryLibrary.computePositions(f,l,p,d,c,!0);if(!e.defined(h))return;const g=h.bottomPositions,y=h.topPositions,C=h.numCorners;let F=y.length,D=2*F;const H=u.position?new Float64Array(D):void 0,L=u.normal?new Float32Array(D):void 0,V=u.tangent?new Float32Array(D):void 0,k=u.bitangent?new Float32Array(D):void 0,G=u.st?new Float32Array(D/3*2):void 0;let P,T=0,z=0,O=0,R=0,S=0,I=_,q=A,N=v,M=!0;F/=3;let W=0;const B=1/(F-C-1);for(P=0;P<F;++P){const e=3*P,i=t.Cartesian3.fromArray(y,e,w),r=t.Cartesian3.fromArray(g,e,b);if(u.position&&(H[T++]=r.x,H[T++]=r.y,H[T++]=r.z,H[T++]=i.x,H[T++]=i.y,H[T++]=i.z),u.st&&(G[S++]=W,G[S++]=0,G[S++]=W,G[S++]=1),u.normal||u.tangent||u.bitangent){let r=t.Cartesian3.clone(t.Cartesian3.ZERO,E);const a=t.Cartesian3.subtract(i,f.geodeticSurfaceNormal(i,b),b);if(P+1<F&&(r=t.Cartesian3.fromArray(y,e+3,E)),M){const e=t.Cartesian3.subtract(r,i,x),n=t.Cartesian3.subtract(a,i,w);I=t.Cartesian3.normalize(t.Cartesian3.cross(n,e,I),I),M=!1}t.Cartesian3.equalsEpsilon(i,r,n.CesiumMath.EPSILON10)?M=!0:(W+=B,u.tangent&&(q=t.Cartesian3.normalize(t.Cartesian3.subtract(r,i,q),q)),u.bitangent&&(N=t.Cartesian3.normalize(t.Cartesian3.cross(I,q,N),N))),u.normal&&(L[z++]=I.x,L[z++]=I.y,L[z++]=I.z,L[z++]=I.x,L[z++]=I.y,L[z++]=I.z),u.tangent&&(V[R++]=q.x,V[R++]=q.y,V[R++]=q.z,V[R++]=q.x,V[R++]=q.y,V[R++]=q.z),u.bitangent&&(k[O++]=N.x,k[O++]=N.y,k[O++]=N.z,k[O++]=N.x,k[O++]=N.y,k[O++]=N.z)}}const U=new o.GeometryAttributes;u.position&&(U.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H})),u.normal&&(U.normal=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),u.tangent&&(U.tangent=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),u.bitangent&&(U.bitangent=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),u.st&&(U.st=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:G}));const J=D/3;D-=6*(C+1);const Y=s.IndexDatatype.createTypedArray(J,D);let j=0;for(P=0;P<J-2;P+=2){const e=P,i=P+2,r=t.Cartesian3.fromArray(H,3*e,w),a=t.Cartesian3.fromArray(H,3*i,b);if(t.Cartesian3.equalsEpsilon(r,a,n.CesiumMath.EPSILON10))continue;const o=P+1,s=P+3;Y[j++]=o,Y[j++]=e,Y[j++]=s,Y[j++]=s,Y[j++]=e,Y[j++]=i}return new a.Geometry({attributes:U,indices:Y,primitiveType:a.PrimitiveType.TRIANGLES,boundingSphere:new i.BoundingSphere.fromVertices(H)})},function(i,n){return e.defined(n)&&(i=F.unpack(i,n)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),F.createGeometry(i)}}));
//# sourceMappingURL=createWallGeometry.js.map
